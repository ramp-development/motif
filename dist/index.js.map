{
  "version": 3,
  "sources": ["../bin/live-reload.js", "../src/lib/core/events/event-bus.ts", "../src/lib/core/storage/adapters/cookie-adapter.ts", "../src/lib/core/storage/adapters/local-storage-adapter.ts", "../src/lib/core/storage/adapters/memory-adapter.ts", "../src/lib/core/storage/adapters/session-storage-adapter.ts", "../src/lib/core/storage/storage-manager.ts", "../src/lib/core/storage/persistance-manager.ts", "../src/lib/core/state/state-manager.ts", "../src/lib/types/core/component-types.ts", "../src/lib/core/components/base-component.ts", "../src/lib/core/components/interactive-component.ts", "../src/lib/core/components/stateful-component.ts", "../src/form/constants/attr.ts", "../src/form/constants/valid-behavior-type-map.ts", "../src/form/constants/valid-element-type-map.ts", "../src/form/constants/valid-error-display-type-map.ts", "../src/form/constants/valid-storage-type-map.ts", "../src/form/constants/valid-transition-type-map.ts", "../src/form/utils/managers/hierarchy-builder.ts", "../src/form/utils/managers/item-store.ts", "../src/form/utils/parsing/generate-id-from-title.ts", "../src/form/utils/parsing/extract-title.ts", "../src/form/utils/parsing/get-config-attributes.ts", "../src/form/utils/parsing/parse-boolean-attribute.ts", "../src/form/utils/validation/is-valid-type.ts", "../src/form/utils/validation/assert-valid-type.ts", "../src/form/utils/validation/behavior-type-validators.ts", "../src/form/utils/validation/element-type-validators.ts", "../src/form/utils/validation/error-mode-type-validators.ts", "../src/form/utils/validation/storage-type-validators.ts", "../src/form/utils/validation/transition-type-validators.ts", "../src/form/utils/parsing/parse-element-attribute.ts", "../src/form/utils/parsing/parse-number-attribute.ts", "../src/form/utils/string/plural.ts", "../src/form/utils/string/sentence-case.ts", "../src/form/managers/base-manager.ts", "../src/form/managers/button-manager.ts", "../src/form/managers/item-manager.ts", "../src/form/managers/card-manager.ts", "../src/form/managers/condition-manager.ts", "../src/form/managers/display-manager.ts", "../src/form/managers/error-manager.ts", "../src/form/managers/field-manager.ts", "../src/form/managers/focus-manager.ts", "../src/form/managers/group-manager.ts", "../src/form/managers/input-manager.ts", "../src/form/managers/navigation-manager.ts", "../src/form/managers/progress-manager.ts", "../src/form/managers/set-manager.ts", "../src/form/managers/submit-manager.ts", "../src/form/index.ts", "../src/index.ts"],
  "sourcesContent": ["new EventSource(`${SERVE_ORIGIN}/esbuild`).addEventListener('change', () => location.reload());\n", "/**\n * Type-safe EventBus implementation with advanced features\n */\n\nimport type {\n  AppEventMap,\n  EventBusConfig,\n  EventEmitOptions,\n  EventHandler,\n  EventHandlerWrapper,\n  EventSubscriptionOptions,\n  IEventBus,\n  UnsubscribeFn,\n} from '$lib/types';\n\nexport class EventBus implements IEventBus<AppEventMap> {\n  private static instance: EventBus;\n  private events: Map<keyof AppEventMap, EventHandlerWrapper[]> = new Map();\n  private config: Required<EventBusConfig>;\n  private handlerIdCounter = 0;\n\n  private constructor(config: EventBusConfig = {}) {\n    this.config = {\n      maxListeners: config.maxListeners ?? 0,\n      errorHandler: config.errorHandler ?? this.defaultErrorHandler,\n      debug: config.debug ?? false,\n    };\n  }\n\n  static getInstance(config?: EventBusConfig): EventBus {\n    if (!EventBus.instance) {\n      EventBus.instance = new EventBus(config);\n    }\n    return EventBus.instance;\n  }\n\n  on<K extends keyof AppEventMap>(\n    event: K,\n    handler: EventHandler<AppEventMap[K]>,\n    options: EventSubscriptionOptions = {}\n  ): UnsubscribeFn {\n    if (!this.events.has(event)) {\n      this.events.set(event, []);\n    }\n\n    const handlers = this.events.get(event)!;\n\n    // Check max listeners\n    if (this.config.maxListeners > 0 && handlers.length >= this.config.maxListeners) {\n      console.error(\n        `[EventBus] Max listeners (${this.config.maxListeners}) reached for event \"${String(\n          event\n        )}\"`\n      );\n    }\n\n    this.handlerIdCounter += 1;\n    const wrapper: EventHandlerWrapper<AppEventMap[K]> = {\n      handler,\n      options,\n      id: `handler-${this.handlerIdCounter}`,\n    };\n\n    // Insert based on priority\n    const priority = options.priority ?? 0;\n    const insertIndex = handlers.findIndex((h) => (h.options.priority ?? 0) < priority);\n\n    if (insertIndex === -1) {\n      handlers.push(wrapper);\n    } else {\n      handlers.splice(insertIndex, 0, wrapper);\n    }\n\n    // Return unsubscribe function\n    return () => {\n      this.off(event, handler);\n    };\n  }\n\n  once<K extends keyof AppEventMap>(\n    event: K,\n    handler: EventHandler<AppEventMap[K]>\n  ): UnsubscribeFn {\n    return this.on(event, handler, { once: true });\n  }\n\n  off<K extends keyof AppEventMap>(event: K, handler?: EventHandler<AppEventMap[K]>): void {\n    const handlers = this.events.get(event);\n    if (!handlers) return;\n\n    if (!handler) {\n      // Remove all handlers for this event\n      this.events.delete(event);\n      return;\n    }\n\n    // Remove specific handler\n    const index = handlers.findIndex((h) => h.handler === handler);\n    if (index !== -1) {\n      handlers.splice(index, 1);\n    }\n\n    // Clean up empty handler arrays\n    if (handlers.length === 0) {\n      this.events.delete(event);\n    }\n  }\n\n  emit<K extends keyof AppEventMap>(\n    event: K,\n    payload: AppEventMap[K],\n    options: EventEmitOptions = {}\n  ): void {\n    const handlers = this.events.get(event);\n    if (!handlers || handlers.length === 0) {\n      return;\n    }\n\n    // Create a copy to handle modifications during iteration\n    const handlersToExecute = [...handlers];\n\n    for (const wrapper of handlersToExecute) {\n      try {\n        // Apply context if provided\n        const context = wrapper.options.context ?? undefined;\n        wrapper.handler.call(context, payload);\n\n        // Remove if it was a one-time handler\n        if (wrapper.options.once) {\n          this.off(event, wrapper.handler);\n        }\n      } catch (error) {\n        if (options.throwOnError) {\n          throw error;\n        }\n        this.config.errorHandler(error as Error, String(event));\n      }\n    }\n  }\n\n  async emitAsync<K extends keyof AppEventMap>(\n    event: K,\n    payload: AppEventMap[K],\n    options: EventEmitOptions = {}\n  ): Promise<void> {\n    const handlers = this.events.get(event);\n    if (!handlers || handlers.length === 0) {\n      return;\n    }\n\n    const handlersToExecute = [...handlers];\n    const promises: Promise<void>[] = [];\n\n    for (const wrapper of handlersToExecute) {\n      const promise = (async () => {\n        try {\n          const context = wrapper.options.context ?? undefined;\n          await wrapper.handler.call(context, payload);\n\n          if (wrapper.options.once) {\n            this.off(event, wrapper.handler);\n          }\n        } catch (error) {\n          if (options.throwOnError) {\n            throw error;\n          }\n          this.config.errorHandler(error as Error, String(event));\n        }\n      })();\n\n      promises.push(promise);\n    }\n\n    await Promise.all(promises);\n  }\n\n  listenerCount<K extends keyof AppEventMap>(event: K): number {\n    return this.events.get(event)?.length ?? 0;\n  }\n\n  removeAllListeners<K extends keyof AppEventMap>(event?: K): void {\n    if (event) {\n      this.events.delete(event);\n    } else {\n      this.events.clear();\n    }\n  }\n\n  setMaxListeners(max: number): void {\n    this.config.maxListeners = max;\n  }\n\n  getMaxListeners(): number {\n    return this.config.maxListeners;\n  }\n\n  setDebugMode(enabled: boolean): void {\n    this.config.debug = enabled;\n  }\n\n  private defaultErrorHandler(error: Error, eventName: string): void {\n    console.error(`[EventBus] Error in handler for \"${eventName}\":`, error);\n  }\n\n  // Helper method to get all event names\n  getEventNames(): (keyof AppEventMap)[] {\n    return Array.from(this.events.keys());\n  }\n\n  // Helper method to check if event has listeners\n  hasListeners<K extends keyof AppEventMap>(event: K): boolean {\n    return this.listenerCount(event) > 0;\n  }\n\n  // Cleanup method\n  destroy(): void {\n    this.removeAllListeners();\n    if (EventBus.instance === this) {\n      // @ts-expect-error - Clearing singleton instance\n      EventBus.instance = undefined;\n    }\n  }\n}\n", "import type { IStorageAdapter, StorageOptions, StorageValue } from '$lib/types';\n\n/**\n * Cookie storage adapter\n */\nexport class CookieAdapter implements IStorageAdapter {\n  private prefix = 'toolkit_';\n\n  private getFullKey(key: string): string {\n    return `${this.prefix}${key}`;\n  }\n\n  private parseCookies(): Record<string, string> {\n    const cookies: Record<string, string> = {};\n    document.cookie.split(';').forEach((cookie) => {\n      const [name, value] = cookie.trim().split('=');\n      if (name && value) {\n        cookies[name] = decodeURIComponent(value);\n      }\n    });\n    return cookies;\n  }\n\n  private setCookie(name: string, value: string, options?: StorageOptions): void {\n    const encodedValue = encodeURIComponent(value);\n    let cookieString = `${name}=${encodedValue}`;\n\n    // Add expiration\n    if (options?.ttl) {\n      const expires = new Date(Date.now() + options.ttl);\n      cookieString += `; expires=${expires.toUTCString()}`;\n    }\n\n    // Add path\n    cookieString += `; path=${options?.path || '/'}`;\n\n    // Add domain\n    if (options?.domain) {\n      cookieString += `; domain=${options.domain}`;\n    }\n\n    // Add secure flag\n    if (options?.secure) {\n      cookieString += '; secure';\n    }\n\n    // Add SameSite\n    if (options?.sameSite) {\n      cookieString += `; samesite=${options.sameSite}`;\n    }\n\n    document.cookie = cookieString;\n  }\n\n  private deleteCookie(name: string): void {\n    // Set cookie with past expiration to delete it\n    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/`;\n  }\n\n  get(key: string): StorageValue | null {\n    try {\n      const fullKey = this.getFullKey(key);\n      const cookies = this.parseCookies();\n      const value = cookies[fullKey];\n\n      if (!value) return null;\n\n      // Try to parse as JSON\n      try {\n        const parsed = JSON.parse(value);\n\n        // Check if it's a wrapped value with metadata\n        if (parsed && typeof parsed === 'object' && '_value' in parsed) {\n          // Check expiration (cookies handle their own expiration, but we double-check)\n          if (parsed._expires && parsed._expires < Date.now()) {\n            this.deleteCookie(fullKey);\n            return null;\n          }\n          return parsed._value;\n        }\n\n        return parsed;\n      } catch {\n        // If not valid JSON, return as string\n        return value;\n      }\n    } catch (error) {\n      console.error(`Failed to get cookie: ${key}`, error);\n      return null;\n    }\n  }\n\n  set(key: string, value: StorageValue, options?: StorageOptions): void {\n    try {\n      const fullKey = this.getFullKey(key);\n      const wrapper = {\n        _value: value,\n        _created: Date.now(),\n        _expires: options?.ttl ? Date.now() + options.ttl : undefined,\n      };\n\n      const serialized = JSON.stringify(wrapper);\n\n      // Check cookie size limit (4KB)\n      if (serialized.length > 4096) {\n        throw new Error(`Cookie value too large: ${serialized.length} bytes`);\n      }\n\n      this.setCookie(fullKey, serialized, options);\n    } catch (error) {\n      console.error(`Failed to set cookie: ${key}`, error);\n      throw error;\n    }\n  }\n\n  remove(key: string): void {\n    this.deleteCookie(this.getFullKey(key));\n  }\n\n  clear(): void {\n    // Clear all cookies with our prefix\n    const cookies = this.parseCookies();\n    Object.keys(cookies).forEach((name) => {\n      if (name.startsWith(this.prefix)) {\n        this.deleteCookie(name);\n      }\n    });\n  }\n\n  has(key: string): boolean {\n    return this.get(key) !== null;\n  }\n\n  keys(): string[] {\n    const cookies = this.parseCookies();\n    return Object.keys(cookies)\n      .filter((name) => name.startsWith(this.prefix))\n      .map((name) => name.substring(this.prefix.length));\n  }\n\n  size(): number {\n    return this.keys().length;\n  }\n}\n", "import type { IStorageAdapter, StorageOptions, StorageValue } from '$lib/types';\n\n/**\n * LocalStorage adapter with TTL support\n */\nexport class LocalStorageAdapter implements IStorageAdapter {\n  private prefix = 'toolkit_';\n\n  private getFullKey(key: string): string {\n    return `${this.prefix}${key}`;\n  }\n\n  private isStorageAvailable(): boolean {\n    try {\n      const testKey = '__toolkit_test__';\n      localStorage.setItem(testKey, 'test');\n      localStorage.removeItem(testKey);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  get(key: string): StorageValue | null {\n    if (!this.isStorageAvailable()) return null;\n\n    try {\n      const fullKey = this.getFullKey(key);\n      const item = localStorage.getItem(fullKey);\n      if (!item) return null;\n\n      const parsed = JSON.parse(item);\n\n      // Check if it's a wrapped value with metadata\n      if (parsed && typeof parsed === 'object' && '_value' in parsed) {\n        // Check expiration\n        if (parsed._expires && parsed._expires < Date.now()) {\n          localStorage.removeItem(fullKey);\n          return null;\n        }\n        return parsed._value;\n      }\n\n      // Legacy support for direct values\n      return parsed;\n    } catch (error) {\n      console.error(`Failed to get value from localStorage: ${key}`, error);\n      return null;\n    }\n  }\n\n  set(key: string, value: StorageValue, options?: StorageOptions): void {\n    if (!this.isStorageAvailable()) return;\n\n    try {\n      const fullKey = this.getFullKey(key);\n      const wrapper = {\n        _value: value,\n        _created: Date.now(),\n        _expires: options?.ttl ? Date.now() + options.ttl : undefined,\n      };\n\n      localStorage.setItem(fullKey, JSON.stringify(wrapper));\n    } catch (error) {\n      console.error(`Failed to set value in localStorage: ${key}`, error);\n      // Handle quota exceeded error\n      if (error instanceof DOMException && error.name === 'QuotaExceededError') {\n        // Try to clear some space by removing expired items\n        this.clearExpired();\n        try {\n          const fullKey = this.getFullKey(key);\n          localStorage.setItem(fullKey, JSON.stringify({ _value: value, _created: Date.now() }));\n        } catch {\n          throw new Error('Storage quota exceeded and unable to clear space');\n        }\n      }\n    }\n  }\n\n  remove(key: string): void {\n    if (!this.isStorageAvailable()) return;\n    localStorage.removeItem(this.getFullKey(key));\n  }\n\n  clear(): void {\n    if (!this.isStorageAvailable()) return;\n\n    // Only clear items with our prefix\n    const keysToRemove: string[] = [];\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key?.startsWith(this.prefix)) {\n        keysToRemove.push(key);\n      }\n    }\n\n    keysToRemove.forEach((key) => localStorage.removeItem(key));\n  }\n\n  has(key: string): boolean {\n    return this.get(key) !== null;\n  }\n\n  keys(): string[] {\n    if (!this.isStorageAvailable()) return [];\n\n    const keys: string[] = [];\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key?.startsWith(this.prefix)) {\n        // Remove prefix to get the actual key\n        keys.push(key.substring(this.prefix.length));\n      }\n    }\n    return keys;\n  }\n\n  size(): number {\n    return this.keys().length;\n  }\n\n  private clearExpired(): void {\n    const keys = this.keys();\n    const now = Date.now();\n\n    keys.forEach((key) => {\n      try {\n        const fullKey = this.getFullKey(key);\n        const item = localStorage.getItem(fullKey);\n        if (item) {\n          const parsed = JSON.parse(item);\n          if (parsed._expires && parsed._expires < now) {\n            localStorage.removeItem(fullKey);\n          }\n        }\n      } catch {\n        // Invalid item, remove it\n        localStorage.removeItem(this.getFullKey(key));\n      }\n    });\n  }\n}\n", "import type { IStorageAdapter, StorageOptions, StorageValue } from '$lib/types';\n\n/**\n * In-memory storage adapter\n */\nexport class MemoryAdapter implements IStorageAdapter {\n  private storage: Map<string, { value: StorageValue; expires?: number }> = new Map();\n\n  get(key: string): StorageValue | null {\n    const item = this.storage.get(key);\n    if (!item) return null;\n\n    // Check if expired\n    if (item.expires && item.expires < Date.now()) {\n      this.storage.delete(key);\n      return null;\n    }\n\n    return item.value;\n  }\n\n  set(key: string, value: StorageValue, options?: StorageOptions): void {\n    const item: { value: StorageValue; expires?: number } = { value };\n    if (options?.ttl) {\n      item.expires = Date.now() + options.ttl;\n    }\n    this.storage.set(key, item);\n  }\n\n  remove(key: string): void {\n    this.storage.delete(key);\n  }\n\n  clear(): void {\n    this.storage.clear();\n  }\n\n  has(key: string): boolean {\n    const value = this.get(key);\n    return value !== null;\n  }\n\n  keys(): string[] {\n    // Clean up expired items first\n    const now = Date.now();\n    for (const [key, item] of this.storage.entries()) {\n      if (item.expires && item.expires < now) {\n        this.storage.delete(key);\n      }\n    }\n    return Array.from(this.storage.keys());\n  }\n\n  size(): number {\n    return this.keys().length;\n  }\n}\n", "import type { IStorageAdapter, StorageOptions, StorageValue } from '$lib/types';\n\n/**\n * SessionStorage adapter with TTL support\n */\nexport class SessionStorageAdapter implements IStorageAdapter {\n  private prefix = 'toolkit_';\n\n  private getFullKey(key: string): string {\n    return `${this.prefix}${key}`;\n  }\n\n  private isStorageAvailable(): boolean {\n    try {\n      const testKey = '__toolkit_test__';\n      sessionStorage.setItem(testKey, 'test');\n      sessionStorage.removeItem(testKey);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  get(key: string): StorageValue | null {\n    if (!this.isStorageAvailable()) return null;\n\n    try {\n      const fullKey = this.getFullKey(key);\n      const item = sessionStorage.getItem(fullKey);\n      if (!item) return null;\n\n      const parsed = JSON.parse(item);\n\n      // Check if it's a wrapped value with metadata\n      if (parsed && typeof parsed === 'object' && '_value' in parsed) {\n        // Check expiration\n        if (parsed._expires && parsed._expires < Date.now()) {\n          sessionStorage.removeItem(fullKey);\n          return null;\n        }\n        return parsed._value;\n      }\n\n      // Legacy support for direct values\n      return parsed;\n    } catch (error) {\n      console.error(`Failed to get value from sessionStorage: ${key}`, error);\n      return null;\n    }\n  }\n\n  set(key: string, value: StorageValue, options?: StorageOptions): void {\n    if (!this.isStorageAvailable()) return;\n\n    try {\n      const fullKey = this.getFullKey(key);\n      const wrapper = {\n        _value: value,\n        _created: Date.now(),\n        _expires: options?.ttl ? Date.now() + options.ttl : undefined,\n      };\n\n      sessionStorage.setItem(fullKey, JSON.stringify(wrapper));\n    } catch (error) {\n      console.error(`Failed to set value in sessionStorage: ${key}`, error);\n      // Handle quota exceeded error\n      if (error instanceof DOMException && error.name === 'QuotaExceededError') {\n        // Try to clear some space by removing expired items\n        this.clearExpired();\n        try {\n          const fullKey = this.getFullKey(key);\n          sessionStorage.setItem(fullKey, JSON.stringify({ _value: value, _created: Date.now() }));\n        } catch {\n          throw new Error('Storage quota exceeded and unable to clear space');\n        }\n      }\n    }\n  }\n\n  remove(key: string): void {\n    if (!this.isStorageAvailable()) return;\n    sessionStorage.removeItem(this.getFullKey(key));\n  }\n\n  clear(): void {\n    if (!this.isStorageAvailable()) return;\n\n    // Only clear items with our prefix\n    const keysToRemove: string[] = [];\n    for (let i = 0; i < sessionStorage.length; i++) {\n      const key = sessionStorage.key(i);\n      if (key?.startsWith(this.prefix)) {\n        keysToRemove.push(key);\n      }\n    }\n\n    keysToRemove.forEach((key) => sessionStorage.removeItem(key));\n  }\n\n  has(key: string): boolean {\n    return this.get(key) !== null;\n  }\n\n  keys(): string[] {\n    if (!this.isStorageAvailable()) return [];\n\n    const keys: string[] = [];\n    for (let i = 0; i < sessionStorage.length; i++) {\n      const key = sessionStorage.key(i);\n      if (key?.startsWith(this.prefix)) {\n        // Remove prefix to get the actual key\n        keys.push(key.substring(this.prefix.length));\n      }\n    }\n    return keys;\n  }\n\n  size(): number {\n    return this.keys().length;\n  }\n\n  private clearExpired(): void {\n    const keys = this.keys();\n    const now = Date.now();\n\n    keys.forEach((key) => {\n      try {\n        const fullKey = this.getFullKey(key);\n        const item = sessionStorage.getItem(fullKey);\n        if (item) {\n          const parsed = JSON.parse(item);\n          if (parsed._expires && parsed._expires < now) {\n            sessionStorage.removeItem(fullKey);\n          }\n        }\n      } catch {\n        // Invalid item, remove it\n        sessionStorage.removeItem(this.getFullKey(key));\n      }\n    });\n  }\n}\n", "import type {\n  IStorageAdapter,\n  IStorageManager,\n  StorageOptions,\n  StorageType,\n  StorageValue,\n} from '$lib/types';\n\nimport { EventBus } from '../events';\nimport {\n  CookieAdapter,\n  LocalStorageAdapter,\n  MemoryAdapter,\n  SessionStorageAdapter,\n} from './adapters';\n\n/**\n * Manages different storage adapters and provides a unified interface\n */\nexport class StorageManager implements IStorageManager {\n  private static instance: StorageManager;\n  private adapters: Map<StorageType, IStorageAdapter>;\n  private defaultType: StorageType = 'memory';\n  private eventBus: EventBus;\n\n  private constructor() {\n    this.eventBus = EventBus.getInstance();\n    this.adapters = new Map<StorageType, IStorageAdapter>();\n    this.adapters.set('memory', new MemoryAdapter());\n    this.adapters.set('local', new LocalStorageAdapter());\n    this.adapters.set('session', new SessionStorageAdapter());\n    this.adapters.set('cookie', new CookieAdapter());\n  }\n\n  static getInstance(): StorageManager {\n    if (!StorageManager.instance) {\n      StorageManager.instance = new StorageManager();\n    }\n    return StorageManager.instance;\n  }\n\n  static init(): void {\n    StorageManager.getInstance();\n  }\n\n  /**\n   * Get a specific storage adapter\n   */\n  getAdapter(type: StorageType): IStorageAdapter {\n    const adapter = this.adapters.get(type);\n    if (!adapter) {\n      throw new Error(`Storage adapter not found: ${type}`);\n    }\n    return adapter;\n  }\n\n  /**\n   * Set the default storage type\n   */\n  setDefaultType(type: StorageType): void {\n    if (!this.adapters.has(type)) {\n      throw new Error(`Invalid storage type: ${type}`);\n    }\n    this.defaultType = type;\n  }\n\n  /**\n   * Get a value from storage\n   */\n  get(key: string, type: StorageType = this.defaultType): StorageValue | null {\n    try {\n      const adapter = this.getAdapter(type);\n      const value = adapter.get(key);\n\n      this.eventBus.emit('storage:get', { key, type });\n\n      return value;\n    } catch (error) {\n      this.eventBus.emit('storage:error', {\n        error: error as Error,\n        operation: 'get',\n        key,\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Set a value in storage\n   */\n  set(\n    key: string,\n    value: StorageValue,\n    type: StorageType = this.defaultType,\n    options?: StorageOptions\n  ): void {\n    try {\n      const adapter = this.getAdapter(type);\n      adapter.set(key, value, options);\n\n      this.eventBus.emit('storage:set', { key, value, type });\n    } catch (error) {\n      this.eventBus.emit('storage:error', {\n        error: error as Error,\n        operation: 'set',\n        key,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Remove a value from storage\n   */\n  remove(key: string, type: StorageType = this.defaultType): void {\n    try {\n      const adapter = this.getAdapter(type);\n      adapter.remove(key);\n\n      this.eventBus.emit('storage:remove', { key, type });\n    } catch (error) {\n      this.eventBus.emit('storage:error', {\n        error: error as Error,\n        operation: 'remove',\n        key,\n      });\n    }\n  }\n\n  /**\n   * Clear all values from a storage type\n   */\n  clear(type: StorageType = this.defaultType): void {\n    try {\n      const adapter = this.getAdapter(type);\n      adapter.clear();\n\n      this.eventBus.emit('storage:clear', { type });\n    } catch (error) {\n      this.eventBus.emit('storage:error', {\n        error: error as Error,\n        operation: 'clear',\n      });\n    }\n  }\n\n  /**\n   * Check if a key exists in storage\n   */\n  has(key: string, type: StorageType = this.defaultType): boolean {\n    try {\n      const adapter = this.getAdapter(type);\n      return adapter.has(key);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get all keys from a storage type\n   */\n  keys(type: StorageType = this.defaultType): string[] {\n    try {\n      const adapter = this.getAdapter(type);\n      return adapter.keys();\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Get the size of a storage type\n   */\n  size(type: StorageType = this.defaultType): number {\n    try {\n      const adapter = this.getAdapter(type);\n      return adapter.size();\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Copy a value from one storage type to another\n   */\n  copy(key: string, fromType: StorageType, toType: StorageType, options?: StorageOptions): boolean {\n    try {\n      const value = this.get(key, fromType);\n      if (value === null) return false;\n\n      this.set(key, value, toType, options);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Move a value from one storage type to another\n   */\n  move(key: string, fromType: StorageType, toType: StorageType, options?: StorageOptions): boolean {\n    try {\n      const copied = this.copy(key, fromType, toType, options);\n      if (copied) {\n        this.remove(key, fromType);\n        return true;\n      }\n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get storage statistics\n   */\n  getStats(): Record<StorageType, { keys: number; available: boolean }> {\n    const stats: Record<StorageType, { keys: number; available: boolean }> = {\n      memory: { keys: 0, available: true },\n      local: { keys: 0, available: true },\n      session: { keys: 0, available: true },\n      cookie: { keys: 0, available: true },\n    };\n\n    for (const [type, adapter] of this.adapters.entries()) {\n      try {\n        stats[type] = {\n          keys: adapter.size(),\n          available: true,\n        };\n      } catch {\n        stats[type] = {\n          keys: 0,\n          available: false,\n        };\n      }\n    }\n\n    return stats;\n  }\n}\n", "import type { IPersistenceManager, PersistenceConfig, StorageValue } from '$lib/types';\n\nimport { StorageManager } from './storage-manager';\n\n/**\n * Manages data persistence with versioning and migration support\n */\nexport class PersistenceManager implements IPersistenceManager {\n  private static instance: PersistenceManager;\n  private storageManager: StorageManager;\n  // EventBus can be used for persistence events in the future\n  // private eventBus: EventBus;\n  private migrations: Map<string, Map<number, (data: unknown) => unknown>> = new Map();\n\n  private constructor() {\n    this.storageManager = StorageManager.getInstance();\n  }\n\n  static getInstance(): PersistenceManager {\n    if (!PersistenceManager.instance) {\n      PersistenceManager.instance = new PersistenceManager();\n    }\n    return PersistenceManager.instance;\n  }\n\n  static init(): void {\n    PersistenceManager.getInstance();\n  }\n\n  /**\n   * Save data with persistence configuration\n   */\n  save(key: string, data: unknown, config: PersistenceConfig): void {\n    try {\n      // Filter data based on include/exclude\n      const filteredData = this.filterData(data, config);\n\n      // Serialize data\n      const serialized = config.serialize\n        ? config.serialize(filteredData)\n        : this.defaultSerialize(filteredData);\n\n      // Create metadata wrapper\n      const wrapper = {\n        _data: serialized,\n        _version: config.version || 1,\n        _saved: Date.now(),\n        _key: config.key,\n      };\n\n      // Save to storage\n      this.storageManager.set(\n        this.getStorageKey(key, config),\n        wrapper as StorageValue,\n        config.storage,\n        config.options\n      );\n    } catch (error) {\n      console.error(`Failed to persist data: ${key}`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load data with persistence configuration\n   */\n  load(key: string, config: PersistenceConfig): unknown | null {\n    try {\n      // Load from storage\n      const wrapper = this.storageManager.get(this.getStorageKey(key, config), config.storage) as {\n        _data: StorageValue;\n        _version: number;\n      } | null;\n\n      if (!wrapper || !wrapper._data) {\n        return null;\n      }\n\n      // Check version and migrate if needed\n      let data: StorageValue = wrapper._data;\n      if (wrapper._version !== (config.version || 1)) {\n        const migratedData = this.migrateData(\n          config.key,\n          data,\n          wrapper._version,\n          config.version || 1\n        );\n        if (migratedData !== null) {\n          data = migratedData;\n        }\n      }\n\n      // Deserialize data\n      const deserialized = config.deserialize\n        ? config.deserialize(data)\n        : this.defaultDeserialize(data);\n\n      return deserialized;\n    } catch (error) {\n      console.error(`Failed to load persisted data: ${key}`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Remove persisted data\n   */\n  remove(key: string, config: PersistenceConfig): void {\n    try {\n      this.storageManager.remove(this.getStorageKey(key, config), config.storage);\n    } catch (error) {\n      console.error(`Failed to remove persisted data: ${key}`, error);\n    }\n  }\n\n  /**\n   * Register a migration function\n   */\n  registerMigration(\n    key: string,\n    fromVersion: number,\n    _toVersion: number,\n    migrator: (data: unknown) => unknown\n  ): void {\n    if (!this.migrations.has(key)) {\n      this.migrations.set(key, new Map());\n    }\n\n    const keyMigrations = this.migrations.get(key)!;\n    // Store migration by \"from\" version\n    keyMigrations.set(fromVersion, migrator);\n  }\n\n  /**\n   * Migrate data through version changes\n   */\n  migrate(\n    key: string,\n    fromVersion: number,\n    _toVersion: number,\n    migrator: (data: unknown) => unknown\n  ): void {\n    this.registerMigration(key, fromVersion, _toVersion, migrator);\n  }\n\n  /**\n   * Get all persisted keys for a namespace\n   */\n  getPersistedKeys(namespace: string): string[] {\n    const allKeys: string[] = [];\n    const storageTypes = ['memory', 'local', 'session', 'cookie'] as const;\n\n    storageTypes.forEach((type) => {\n      const keys = this.storageManager.keys(type);\n      const namespaceKeys = keys.filter((key) => key.startsWith(`${namespace}:`));\n      allKeys.push(...namespaceKeys);\n    });\n\n    return Array.from(new Set(allKeys));\n  }\n\n  /**\n   * Clear all persisted data for a namespace\n   */\n  clearNamespace(namespace: string): void {\n    const keys = this.getPersistedKeys(namespace);\n    const storageTypes = ['memory', 'local', 'session', 'cookie'] as const;\n\n    keys.forEach((key) => {\n      storageTypes.forEach((type) => {\n        if (this.storageManager.has(key, type)) {\n          this.storageManager.remove(key, type);\n        }\n      });\n    });\n  }\n\n  /**\n   * Export all data for a namespace\n   */\n  exportNamespace(namespace: string): Record<string, unknown> {\n    const keys = this.getPersistedKeys(namespace);\n    const exported: Record<string, unknown> = {};\n    const storageTypes = ['memory', 'local', 'session', 'cookie'] as const;\n\n    keys.forEach((key) => {\n      for (const type of storageTypes) {\n        const value = this.storageManager.get(key, type);\n        if (value !== null) {\n          exported[key] = value;\n          break;\n        }\n      }\n    });\n\n    return exported;\n  }\n\n  /**\n   * Import data for a namespace\n   */\n  importNamespace(\n    namespace: string,\n    data: Record<string, unknown>,\n    targetStorage: 'memory' | 'local' | 'session' | 'cookie' = 'memory'\n  ): void {\n    Object.entries(data).forEach(([key, value]) => {\n      if (key.startsWith(`${namespace}:`)) {\n        this.storageManager.set(key, value as StorageValue, targetStorage);\n      }\n    });\n  }\n\n  /**\n   * Get the storage key for persistence\n   */\n  private getStorageKey(key: string, config: PersistenceConfig): string {\n    return `${config.key}:${key}`;\n  }\n\n  /**\n   * Filter data based on include/exclude configuration\n   */\n  private filterData(data: unknown, config: PersistenceConfig): unknown {\n    if (!data || typeof data !== 'object') {\n      return data;\n    }\n\n    const obj = data as Record<string, unknown>;\n    const filtered: Record<string, unknown> = {};\n\n    // If include is specified, only include those fields\n    if (config.include && config.include.length > 0) {\n      config.include.forEach((field) => {\n        if (field in obj) {\n          filtered[field] = obj[field];\n        }\n      });\n      return filtered;\n    }\n\n    // Otherwise, include all except excluded fields\n    Object.entries(obj).forEach(([key, value]) => {\n      if (!config.exclude || !config.exclude.includes(key)) {\n        filtered[key] = value;\n      }\n    });\n\n    return filtered;\n  }\n\n  /**\n   * Default serialization\n   */\n  private defaultSerialize(data: unknown): StorageValue {\n    // Handle primitive types\n    if (\n      data === null ||\n      typeof data === 'string' ||\n      typeof data === 'number' ||\n      typeof data === 'boolean'\n    ) {\n      return data;\n    }\n\n    // Handle arrays and objects\n    if (Array.isArray(data) || (typeof data === 'object' && data !== null)) {\n      return JSON.parse(JSON.stringify(data)) as StorageValue;\n    }\n\n    // Unsupported type\n    throw new Error(`Cannot serialize data of type: ${typeof data}`);\n  }\n\n  /**\n   * Default deserialization\n   */\n  private defaultDeserialize(data: StorageValue): unknown {\n    return data;\n  }\n\n  /**\n   * Migrate data through versions\n   */\n  private migrateData(\n    key: string,\n    data: StorageValue,\n    fromVersion: number,\n    toVersion: number\n  ): StorageValue {\n    const keyMigrations = this.migrations.get(key);\n    if (!keyMigrations) {\n      // eslint-disable-next-line no-console\n      console.warn(`No migrations found for key: ${key}`);\n      return data;\n    }\n\n    let currentData: unknown = data;\n    let currentVersion = fromVersion;\n\n    // Apply migrations in sequence\n    while (currentVersion < toVersion) {\n      const migrator = keyMigrations.get(currentVersion);\n      if (migrator) {\n        currentData = migrator(currentData);\n      } else {\n        // eslint-disable-next-line no-console\n        console.warn(`No migration found from version ${currentVersion} to ${currentVersion + 1}`);\n      }\n      currentVersion += 1;\n    }\n\n    return currentData as StorageValue;\n  }\n}\n", "import type { StateConfig, StateValue } from '$lib/types';\nimport type { PersistenceConfig, StorageType } from '$lib/types';\n\nimport { EventBus } from '../events';\nimport { PersistenceManager } from '../storage/persistance-manager';\n\n/**\n * Central state management with persistence support\n */\nexport class StateManager {\n  private static instance: StateManager;\n  private state: Map<string, unknown> = new Map();\n  private stateConfigs: Map<string, StateConfig> = new Map();\n  private eventBus: EventBus;\n  // StorageManager is used indirectly through PersistenceManager\n  // private storageManager: StorageManager;\n  private persistenceManager: PersistenceManager;\n  private namespace = 'app-state';\n\n  private constructor() {\n    this.eventBus = EventBus.getInstance();\n    this.persistenceManager = PersistenceManager.getInstance();\n  }\n\n  static getInstance(): StateManager {\n    if (!StateManager.instance) {\n      StateManager.instance = new StateManager();\n    }\n    return StateManager.instance;\n  }\n\n  static init(): void {\n    const instance = StateManager.getInstance();\n    // Restore persisted state on initialization\n    instance.restorePersistedState();\n  }\n\n  /**\n   * Configure state with persistence options\n   */\n  configure(key: string, config: StateConfig): void {\n    this.stateConfigs.set(key, config);\n\n    // Set default value if provided and key doesn't exist\n    if (config.defaultValue !== undefined && !this.state.has(key)) {\n      this.set(key, config.defaultValue, { skipPersist: true });\n    }\n  }\n\n  /**\n   * Set a state value with optional persistence\n   */\n  set(key: string, value: StateValue, options?: { skipPersist?: boolean }): void {\n    const from = this.state.get(key) as StateValue;\n    this.state.set(key, value);\n\n    // Check if we should persist\n    const config = this.stateConfigs.get(key);\n    if (config?.persistent && !options?.skipPersist) {\n      this.persistValue(key, value, config);\n    }\n\n    this.eventBus.emit('state:changed', {\n      key,\n      from,\n      to: value,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Get a state value with type safety\n   */\n  get<T = unknown>(key: string): T | undefined {\n    return this.state.get(key) as T;\n  }\n\n  /**\n   * Get a state value with a fallback\n   */\n  getOrDefault<T = unknown>(key: string, defaultValue: T): T {\n    return this.state.has(key) ? (this.state.get(key) as T) : defaultValue;\n  }\n\n  /**\n   * Check if a state key exists\n   */\n  has(key: string): boolean {\n    return this.state.has(key);\n  }\n\n  /**\n   * Remove a state value\n   */\n  remove(key: string): void {\n    const value = this.state.get(key) as StateValue;\n    const config = this.stateConfigs.get(key);\n\n    this.state.delete(key);\n    this.stateConfigs.delete(key);\n\n    // Remove from persistence if configured\n    if (config?.persistent) {\n      this.removePersistedValue(key, config);\n    }\n\n    this.eventBus.emit('state:removed', {\n      key,\n      value,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Clear all state\n   */\n  clear(options?: { keepPersisted?: boolean }): void {\n    // Store persisted keys if needed\n    const persistedKeys = options?.keepPersisted\n      ? Array.from(this.stateConfigs.entries())\n          .filter(([, config]) => config.persistent)\n          .map(([key]) => key)\n      : [];\n\n    // Clear in-memory state\n    this.state.clear();\n\n    // Clear persistence unless keepPersisted is true\n    if (!options?.keepPersisted) {\n      this.stateConfigs.clear();\n      this.persistenceManager.clearNamespace(this.namespace);\n    } else {\n      // Restore persisted values\n      persistedKeys.forEach((key) => {\n        const config = this.stateConfigs.get(key);\n        if (config) {\n          const value = this.loadPersistedValue(key, config);\n          if (value !== null) {\n            this.state.set(key, value);\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Get all state keys\n   */\n  keys(): string[] {\n    return Array.from(this.state.keys());\n  }\n\n  /**\n   * Get all state entries\n   */\n  entries(): Array<[string, unknown]> {\n    return Array.from(this.state.entries());\n  }\n\n  /**\n   * Get the size of the state\n   */\n  size(): number {\n    return this.state.size;\n  }\n\n  /**\n   * Subscribe to state changes for a specific key\n   */\n  watch(key: string, callback: (value: StateValue, from: StateValue) => void): () => void {\n    const handler = (event: { key: string; to: StateValue; from: StateValue }) => {\n      if (event.key === key) {\n        callback(event.to, event.from);\n      }\n    };\n\n    return this.eventBus.on('state:changed', handler);\n  }\n\n  /**\n   * Create a computed value based on state\n   */\n  computed<T>(keys: string[], compute: (values: Record<string, unknown>) => T): () => T {\n    return () => {\n      const values: Record<string, unknown> = {};\n      keys.forEach((key) => {\n        values[key] = this.get(key);\n      });\n      return compute(values);\n    };\n  }\n\n  /**\n   * Batch update multiple state values\n   */\n  batch(updates: Record<string, StateValue>): void {\n    Object.entries(updates).forEach(([key, value]) => {\n      this.set(key, value);\n    });\n  }\n\n  /**\n   * Export state for debugging or persistence\n   */\n  export(includeConfigs = false): {\n    state: Record<string, unknown>;\n    configs?: Record<string, StateConfig>;\n  } {\n    const exported: Record<string, unknown> = {};\n    this.state.forEach((value, key) => {\n      exported[key] = value;\n    });\n\n    if (includeConfigs) {\n      const configs: Record<string, StateConfig> = {};\n      this.stateConfigs.forEach((config, key) => {\n        configs[key] = config;\n      });\n      return { state: exported, configs };\n    }\n\n    return { state: exported };\n  }\n\n  /**\n   * Import state from an export\n   */\n  import(data: { state: Record<string, StateValue>; configs?: Record<string, StateConfig> }): void {\n    // Import configs first if provided\n    if (data.configs) {\n      Object.entries(data.configs).forEach(([key, config]) => {\n        this.configure(key, config);\n      });\n    }\n\n    // Import state\n    this.batch(data.state);\n  }\n\n  /**\n   * Persist a value based on its configuration\n   */\n  private persistValue(key: string, value: unknown, config: StateConfig): void {\n    const persistConfig: PersistenceConfig = {\n      key: this.namespace,\n      storage: (config.storage || 'local') as StorageType,\n      version: 1,\n    };\n\n    try {\n      this.persistenceManager.save(key, value, persistConfig);\n    } catch (error) {\n      console.error(`Failed to persist state: ${key}`, error);\n    }\n  }\n\n  /**\n   * Load a persisted value\n   */\n  private loadPersistedValue(key: string, config: StateConfig): unknown | null {\n    const persistConfig: PersistenceConfig = {\n      key: this.namespace,\n      storage: (config.storage || 'local') as StorageType,\n      version: 1,\n    };\n\n    try {\n      return this.persistenceManager.load(key, persistConfig);\n    } catch (error) {\n      console.error(`Failed to load persisted state: ${key}`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Remove a persisted value\n   */\n  private removePersistedValue(key: string, config: StateConfig): void {\n    const persistConfig: PersistenceConfig = {\n      key: this.namespace,\n      storage: (config.storage || 'local') as StorageType,\n      version: 1,\n    };\n\n    try {\n      this.persistenceManager.remove(key, persistConfig);\n    } catch (error) {\n      console.error(`Failed to remove persisted state: ${key}`, error);\n    }\n  }\n\n  /**\n   * Restore all persisted state on initialization\n   */\n  private restorePersistedState(): void {\n    this.stateConfigs.forEach((config, key) => {\n      if (config.persistent && !this.state.has(key)) {\n        const value = this.loadPersistedValue(key, config) as StateValue;\n        if (value !== null) {\n          this.set(key, value, { skipPersist: true });\n        }\n      }\n    });\n  }\n}\n", "/**\n * Core component type definitions\n */\n\nimport type { AppEventMap } from '../events';\n\n// Component lifecycle methods\nexport interface ComponentLifecycle {\n  init(): void | Promise<void>;\n  destroy(): void | Promise<void>;\n}\n\n// Component configuration options\nexport interface BaseComponentProps {\n  group?: string;\n  id?: string;\n  className?: string;\n  debug?: boolean;\n  autoInit?: boolean;\n  selector?: ElementSelector; // Optional selector for lazy element initialization\n}\n\n// DOM query options\nexport interface QueryOptions {\n  required?: boolean; // Throw if element not found\n  parent?: HTMLElement | Document; // Parent to search within\n  multiple?: boolean; // Return all matches\n}\n\n// Component metadata\nexport interface ComponentMetadata {\n  name: string;\n  version?: string;\n  initialized: boolean;\n  destroyed: boolean;\n  initTime?: number;\n  destroyTime?: number;\n}\n\n// Event listener configuration\nexport interface ListenerConfig {\n  element: HTMLElement | Window | Document;\n  event: string;\n  handler: EventListener;\n  options?: AddEventListenerOptions | undefined;\n}\n\n// Interactive component configuration\nexport interface InteractiveComponentProps extends BaseComponentProps {\n  events?: {\n    [key: string]: EventListener;\n  };\n  delegateTarget?: string; // For event delegation\n}\n\n// State types\nexport type StateValue = string | number | boolean | object | null;\n\nexport interface ComponentStateConfig {\n  key: string;\n  defaultValue?: StateValue;\n  storage?: 'memory' | 'local' | 'session';\n  validate?: (value: StateValue) => boolean;\n  transform?: (value: StateValue) => StateValue;\n}\n\n// Stateful component configuration\nexport interface StatefulComponentProps extends InteractiveComponentProps {\n  state?: ComponentStateConfig | ComponentStateConfig[];\n  persistState?: boolean;\n  statePrefix?: string; // Prefix for storage keys\n}\n\n// Component state\nexport interface ComponentState {\n  [key: string]: StateValue;\n}\n\n// State change event\nexport interface StateChangeEvent {\n  key: string;\n  from: StateValue;\n  to: StateValue;\n  component: string; // Component ID\n}\n\n// Component error types\nexport class ComponentError extends Error {\n  constructor(\n    message: string,\n    public componentId: string,\n    public phase: 'init' | 'runtime' | 'destroy',\n    public cause?: unknown\n  ) {\n    super(message);\n    this.name = 'ComponentError';\n  }\n}\n\n// DOM utility types\nexport type ElementSelector = string | HTMLElement | null;\nexport type ElementOrNull = HTMLElement | null;\nexport type ElementArray = HTMLElement[];\n\n// Event emitter interface for components\nexport interface ComponentEventEmitter {\n  emit<K extends keyof AppEventMap>(event: K, payload: AppEventMap[K]): void;\n  emitCustom(event: string, detail: unknown): void;\n}\n\n// Storage adapter interface\nexport interface StorageAdapter {\n  get(key: string): StateValue;\n  set(key: string, value: StateValue): void;\n  remove(key: string): void;\n  clear(): void;\n}\n", "/**\n * BaseComponent - Foundation for all components\n * Handles DOM references, lifecycle methods, and safe element access\n */\n\nimport {\n  type BaseComponentProps,\n  ComponentError,\n  type ComponentLifecycle,\n  type ComponentMetadata,\n  type ElementOrNull,\n  type ElementSelector,\n  type QueryOptions,\n} from '$lib/types';\n\nexport abstract class BaseComponent implements ComponentLifecycle {\n  protected readonly group: string | undefined;\n  protected readonly id: string;\n  protected readonly props: BaseComponentProps;\n  protected metadata: ComponentMetadata;\n  protected rootElement: ElementOrNull = null;\n  protected elements: Map<string, HTMLElement> = new Map();\n\n  constructor(props: BaseComponentProps = {}) {\n    this.metadata = {\n      name: this.constructor.name,\n      initialized: false,\n      destroyed: false,\n    };\n\n    this.props = props;\n    this.group = props.group;\n    this.id = props.id || this.generateId();\n\n    // Auto-init if requested\n    if (props.autoInit) {\n      this.init();\n    }\n  }\n\n  /**\n   * Initialize the component\n   */\n  async init(): Promise<void> {\n    if (this.metadata.initialized) {\n      this.logWarn('Component already initialized');\n      return;\n    }\n\n    try {\n      this.metadata.initTime = Date.now();\n\n      // Allow child classes to perform initialization\n      await this.onInit();\n\n      this.metadata.initialized = true;\n    } catch (error) {\n      throw this.createError(`Failed to initialize: ${error}`, 'init');\n    }\n  }\n\n  /**\n   * Destroy the component and clean up resources\n   */\n  async destroy(): Promise<void> {\n    if (this.metadata.destroyed) {\n      this.logWarn('Component already destroyed');\n      return;\n    }\n\n    try {\n      this.metadata.destroyTime = Date.now();\n\n      // Allow child classes to perform cleanup\n      await this.onDestroy();\n\n      // Clear element references\n      this.elements.clear();\n      this.rootElement = null;\n\n      this.metadata.destroyed = true;\n      this.metadata.initialized = false;\n      this.logDebug('Component destroyed');\n    } catch (error) {\n      throw this.createError(`Failed to destroy: ${error}`, 'destroy');\n    }\n  }\n\n  /**\n   * Hook for child classes to implement initialization logic\n   */\n  protected abstract onInit(): void | Promise<void>;\n\n  /**\n   * Hook for child classes to implement cleanup logic\n   */\n  protected abstract onDestroy(): void | Promise<void>;\n\n  /**\n   * Query for a DOM element with enhanced options\n   */\n  public query<T extends HTMLElement = HTMLElement>(\n    selector: ElementSelector,\n    options: QueryOptions = {}\n  ): T | null {\n    const { required = false, parent = this.rootElement || document } = options;\n\n    // Handle direct element passing\n    if (selector instanceof HTMLElement) {\n      return selector as T;\n    }\n\n    if (!selector) {\n      if (required) {\n        throw this.createError('Selector is required', 'runtime');\n      }\n      return null;\n    }\n\n    const element = parent.querySelector<T>(selector as string);\n\n    if (!element && required) {\n      throw this.createError(`Required element not found: ${selector}`, 'runtime');\n    }\n\n    return element;\n  }\n\n  /**\n   * Query for multiple DOM elements\n   */\n  public queryAll<T extends HTMLElement = HTMLElement>(\n    selector: string,\n    options: Omit<QueryOptions, 'multiple'> = {}\n  ): T[] {\n    const { parent = this.rootElement || document } = options;\n    return Array.from(parent.querySelectorAll<T>(selector));\n  }\n\n  /**\n   * Set the root element for the component\n   */\n  protected setRootElement(selector: ElementSelector, options?: QueryOptions): void {\n    const element = this.query(selector, { ...options, required: true });\n    if (element) {\n      this.rootElement = element;\n\n      // Add component identifier\n      element.dataset['componentId'] = this.id;\n\n      if (this.props.className) {\n        element.classList.add(this.props.className);\n      }\n    }\n  }\n\n  /**\n   * Get the root element for the component\n   */\n  public getRootElement<T extends HTMLElement = HTMLElement>(): T | null {\n    return this.rootElement as T | null;\n  }\n\n  /**\n   * Cache an element reference for quick access\n   */\n  protected cacheElement(key: string, selector: ElementSelector, options?: QueryOptions): void {\n    const element = this.query(selector, options);\n    if (element) {\n      this.elements.set(key, element);\n    }\n  }\n\n  /**\n   * Get a cached element\n   */\n  protected getElement(key: string): HTMLElement | null {\n    return this.elements.get(key) || null;\n  }\n\n  /**\n   * Check if component is initialized\n   */\n  isInitialized(): boolean {\n    return this.metadata.initialized && !this.metadata.destroyed;\n  }\n\n  /**\n   * Check if component is destroyed\n   */\n  isDestroyed(): boolean {\n    return this.metadata.destroyed;\n  }\n\n  /**\n   * Get component ID\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * Get component metadata\n   */\n  getMetadata(): Readonly<ComponentMetadata> {\n    return { ...this.metadata };\n  }\n\n  /**\n   * Generate unique component ID\n   */\n  protected generateId(): string {\n    const id = crypto.randomUUID();\n    return `${this.metadata.name}-${id}`;\n  }\n\n  /**\n   * Create a component-specific error\n   */\n  public createError(\n    message: string,\n    phase: 'init' | 'runtime' | 'destroy' = 'runtime',\n    cause?: unknown\n  ): ComponentError {\n    return new ComponentError(`[${this.id}] ${message}`, this.id, phase, cause);\n  }\n\n  /**\n   * Safe element text content setter\n   */\n  protected setText(element: ElementOrNull, text: string): void {\n    if (element) {\n      element.textContent = text;\n    }\n  }\n\n  /**\n   * Safe element HTML setter with optional sanitization\n   */\n  protected setHTML(element: ElementOrNull, html: string, sanitize = false): void {\n    if (!element) return;\n\n    if (sanitize) {\n      // Basic sanitization - in production, use a proper sanitizer like DOMPurify\n      const temp = document.createElement('div');\n      temp.textContent = html;\n      element.innerHTML = temp.innerHTML;\n    } else {\n      element.innerHTML = html;\n    }\n  }\n\n  /**\n   * Safe attribute setter\n   */\n  protected setAttribute(element: ElementOrNull, name: string, value: string): void {\n    if (element) {\n      element.setAttribute(name, value);\n    }\n  }\n\n  /**\n   * Toggle element visibility\n   */\n  protected toggleVisibility(element: ElementOrNull, visible?: boolean): void {\n    if (!element) return;\n\n    if (visible === undefined) {\n      element.hidden = !element.hidden;\n    } else {\n      element.hidden = !visible;\n    }\n  }\n\n  /**\n   * Toggle CSS class\n   */\n  protected toggleClass(element: ElementOrNull, className: string, force?: boolean): void {\n    if (element) {\n      element.classList.toggle(className, force);\n    }\n  }\n\n  /**\n   * Start console group (only in debug mode)\n   */\n  public groupStart(name: string, collapsed = true): void {\n    if (!this.props.debug) return;\n\n    // eslint-disable-next-line no-console\n    if (collapsed) console.groupCollapsed(name);\n    // eslint-disable-next-line no-console\n    else console.group(name);\n  }\n\n  /**\n   * End console group (only in debug mode)\n   */\n  public groupEnd(): void {\n    // eslint-disable-next-line no-console\n    console.groupEnd();\n  }\n\n  /**\n   * Debug timer\n   */\n  public timeDebug(name: string, end: boolean = false): void {\n    if (!this.props.debug) return;\n\n    if (end) {\n      // eslint-disable-next-line no-console\n      console.timeEnd(name);\n    }\n\n    if (!end) {\n      // eslint-disable-next-line no-console\n      console.time(name);\n    }\n  }\n\n  /**\n   * Debug logging (only in debug mode)\n   */\n  public logDebug(...args: unknown[]): void {\n    if (!this.props.debug) return;\n\n    // eslint-disable-next-line no-console\n    console.log(...args);\n  }\n\n  /**\n   * Warning logging\n   */\n  public logWarn(...args: unknown[]): void {\n    // eslint-disable-next-line no-console\n    console.warn(...args);\n  }\n\n  /**\n   * Error logging\n   */\n  public logError(...args: unknown[]): void {\n    console.error(...args);\n  }\n\n  /** Table logging */\n  public logTable(data: unknown[], columns?: string[]): void {\n    // eslint-disable-next-line no-console\n    console.table(data, columns);\n  }\n}\n", "/**\n * InteractiveComponent - Extends BaseComponent with event handling\n * Integrates with EventBus for decoupled communication\n *\n * Generic type TEventMap allows subclasses to define their own event maps\n * that extend the base AppEventMap\n */\n\nimport type {\n  AppEventMap,\n  ComponentEventEmitter,\n  InteractiveComponentProps,\n  ListenerConfig,\n} from '$lib/types';\n\nimport { EventBus } from '../events';\nimport { BaseComponent } from './base-component';\n\nexport abstract class InteractiveComponent<TEventMap extends AppEventMap = AppEventMap>\n  extends BaseComponent\n  implements ComponentEventEmitter\n{\n  protected readonly eventBus: EventBus;\n  protected listeners: Map<string, ListenerConfig> = new Map();\n  protected eventUnsubscribers: Array<() => void> = [];\n  protected delegatedHandlers: Map<string, EventListener> = new Map();\n\n  constructor(props: InteractiveComponentProps = {}) {\n    super(props);\n    this.eventBus = EventBus.getInstance({ debug: true });\n  }\n\n  /**\n   * Initialize component and set up event listeners\n   */\n  protected async onInit(): Promise<void> {\n    await this.setupEventListeners();\n\n    // Initialize custom events if provided in config\n    if ((this.props as InteractiveComponentProps).events) {\n      this.bindConfigEvents();\n    }\n  }\n\n  /**\n   * Clean up all event listeners and subscriptions\n   */\n  protected async onDestroy(): Promise<void> {\n    this.removeAllListeners();\n    this.removeAllSubscriptions();\n    this.removeDelegatedHandlers();\n  }\n\n  /**\n   * Hook for child classes to set up event listeners\n   */\n  protected abstract setupEventListeners(): void | Promise<void>;\n\n  /**\n   * Add an event listener with automatic cleanup\n   */\n  protected addEventListener(\n    target: HTMLElement | Window | Document | string,\n    event: string,\n    handler: EventListener,\n    options?: AddEventListenerOptions\n  ): void {\n    let element: HTMLElement | Window | Document;\n    let key: string;\n\n    // Handle selector-based listeners (cached elements)\n    if (typeof target === 'string') {\n      const cached = this.getElement(target);\n      if (!cached) {\n        this.logWarn(`Cached element not found: ${target}`);\n        return;\n      }\n      element = cached;\n      key = `${target}-${event}`;\n    } else {\n      element = target;\n      key = `${element.constructor.name}-${event}`;\n    }\n\n    // Remove existing listener if present\n    if (this.listeners.has(key)) {\n      this.removeEventListener(key);\n    }\n\n    // Add the listener\n    element.addEventListener(event, handler, options);\n\n    // Store for cleanup\n    this.listeners.set(key, {\n      element,\n      event,\n      handler,\n      options: options || undefined,\n    });\n\n    this.logDebug(`Added listener: ${key}`);\n  }\n\n  /**\n   * Remove a specific event listener\n   */\n  protected removeEventListener(key: string): void {\n    const config = this.listeners.get(key);\n    if (config) {\n      config.element.removeEventListener(config.event, config.handler, config.options);\n      this.listeners.delete(key);\n      this.logDebug(`Removed listener: ${key}`);\n    }\n  }\n\n  /**\n   * Remove all event listeners\n   */\n  protected removeAllListeners(): void {\n    this.listeners.forEach((_, key) => {\n      this.removeEventListener(key);\n    });\n  }\n\n  /**\n   * Set up event delegation for dynamic content\n   */\n  protected delegate(\n    event: string,\n    selector: string,\n    handler: (event: Event, target: HTMLElement) => void,\n    parent: HTMLElement | Document = document\n  ): void {\n    const delegatedHandler: EventListener = (e) => {\n      const target = e.target as HTMLElement;\n      const delegateTarget = target.closest(selector);\n\n      if (delegateTarget && parent.contains(delegateTarget)) {\n        handler.call(this, e, delegateTarget as HTMLElement);\n      }\n    };\n\n    const key = `${event}-${selector}`;\n\n    // Remove existing handler\n    if (this.delegatedHandlers.has(key)) {\n      parent.removeEventListener(event, this.delegatedHandlers.get(key)!);\n    }\n\n    // Add new handler\n    parent.addEventListener(event, delegatedHandler, true);\n    this.delegatedHandlers.set(key, delegatedHandler);\n  }\n\n  /**\n   * Remove delegated event handlers\n   */\n  protected removeDelegatedHandlers(): void {\n    this.delegatedHandlers.forEach((handler, key) => {\n      const [event] = key.split('-');\n      if (event) {\n        document.removeEventListener(event, handler, true);\n      }\n    });\n    this.delegatedHandlers.clear();\n  }\n\n  /**\n   * Subscribe to EventBus events\n   * Uses the component's event map type (TEventMap)\n   */\n  public subscribe<K extends keyof TEventMap>(\n    event: K,\n    handler: (payload: TEventMap[K]) => void,\n    options?: { priority?: number; once?: boolean }\n  ): void {\n    // Type assertion: TEventMap extends AppEventMap, so event keys are compatible\n    // We use 'unknown' for handler payload since EventBus handles all payloads generically\n    const unsubscribe = this.eventBus.on(\n      event as keyof AppEventMap,\n      handler as (payload: unknown) => void,\n      options\n    );\n    this.eventUnsubscribers.push(unsubscribe);\n  }\n\n  /**\n   * Subscribe to a one-time EventBus event\n   * Uses the component's event map type (TEventMap)\n   */\n  protected subscribeOnce<K extends keyof TEventMap>(\n    event: K,\n    handler: (payload: TEventMap[K]) => void\n  ): void {\n    // Type assertion: TEventMap extends AppEventMap, so event keys are compatible\n    const unsubscribe = this.eventBus.once(\n      event as keyof AppEventMap,\n      handler as (payload: unknown) => void\n    );\n    this.eventUnsubscribers.push(unsubscribe);\n  }\n\n  /**\n   * Remove all EventBus subscriptions\n   */\n  protected removeAllSubscriptions(): void {\n    this.eventUnsubscribers.forEach((unsubscribe) => unsubscribe());\n    this.eventUnsubscribers = [];\n  }\n\n  /**\n   * Emit an event through the EventBus\n   * Uses the component's event map type (TEventMap)\n   */\n  emit<K extends keyof TEventMap>(event: K, payload: TEventMap[K]): void {\n    // Type assertion: TEventMap extends AppEventMap, so event keys are compatible\n    this.eventBus.emit(event as keyof AppEventMap, payload as unknown);\n  }\n\n  /**\n   * Emit a custom DOM event\n   */\n  emitCustom(eventName: string, detail: unknown, target?: HTMLElement): void {\n    const element = target || this.rootElement || document.body;\n    const event = new CustomEvent(eventName, {\n      detail,\n      bubbles: true,\n      cancelable: true,\n    });\n    element.dispatchEvent(event);\n  }\n\n  /**\n   * Bind events from configuration\n   */\n  private bindConfigEvents(): void {\n    const config = this.props as InteractiveComponentProps;\n    if (!config.events || !this.rootElement) return;\n\n    Object.entries(config.events).forEach(([eventName, handler]) => {\n      this.addEventListener(this.rootElement!, eventName, handler.bind(this));\n    });\n  }\n\n  /**\n   * Handle click events with optional debouncing\n   */\n  protected onClick(\n    target: HTMLElement | string,\n    handler: (event: MouseEvent) => void,\n    debounceMs = 0\n  ): void {\n    const wrappedHandler =\n      debounceMs > 0\n        ? (this.debounce(handler as (...args: unknown[]) => unknown, debounceMs) as EventListener)\n        : (handler as EventListener);\n\n    this.addEventListener(target, 'click', wrappedHandler);\n  }\n\n  /**\n   * Handle input events with optional debouncing\n   */\n  protected onInput(\n    target: HTMLElement | string,\n    handler: (event: Event) => void,\n    debounceMs = 0\n  ): void {\n    const wrappedHandler =\n      debounceMs > 0\n        ? (this.debounce(handler as (...args: unknown[]) => unknown, debounceMs) as EventListener)\n        : (handler as EventListener);\n\n    this.addEventListener(target, 'input', wrappedHandler);\n  }\n\n  /**\n   * Simple debounce implementation\n   */\n  private debounce<T extends (...args: unknown[]) => unknown>(\n    callback: T,\n    wait: number\n  ): (...args: Parameters<T>) => void {\n    let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n    return (...args: Parameters<T>) => {\n      if (timeoutId !== null) {\n        clearTimeout(timeoutId);\n      }\n\n      timeoutId = setTimeout(() => {\n        callback.apply(this, args);\n      }, wait);\n    };\n  }\n\n  /**\n   * Wait for an element to appear in the DOM\n   */\n  protected async waitForElement(\n    selector: string,\n    timeout = 5000,\n    parent: HTMLElement | Document = document\n  ): Promise<HTMLElement> {\n    return new Promise((resolve, reject) => {\n      const element = parent.querySelector<HTMLElement>(selector);\n      if (element) {\n        resolve(element);\n        return;\n      }\n\n      const observer = new MutationObserver((_, obs) => {\n        const element = parent.querySelector<HTMLElement>(selector);\n        if (element) {\n          obs.disconnect();\n          resolve(element);\n        }\n      });\n\n      observer.observe(parent === document ? document.body : parent, {\n        childList: true,\n        subtree: true,\n      });\n\n      setTimeout(() => {\n        observer.disconnect();\n        reject(this.createError(`Element not found: ${selector}`, 'runtime'));\n      }, timeout);\n    });\n  }\n\n  /**\n   * Get all active listeners (for debugging)\n   */\n  getActiveListeners(): ReadonlyMap<string, ListenerConfig> {\n    return new Map(this.listeners);\n  }\n\n  /**\n   * Get listener count\n   */\n  getListenerCount(): number {\n    return this.listeners.size + this.eventUnsubscribers.length;\n  }\n}\n", "/**\n * StatefulComponent - Extends InteractiveComponent with state management\n * Provides local and persistent state capabilities with change tracking\n */\n\nimport type {\n  AppEventMap,\n  ComponentState,\n  ComponentStateConfig,\n  PersistenceConfig,\n  StateChangeEvent,\n  StatefulComponentProps,\n  StateValue,\n  StorageType,\n} from '$lib/types';\n\nimport { StateManager } from '../state/state-manager';\nimport { PersistenceManager } from '../storage/persistance-manager';\nimport { StorageManager } from '../storage/storage-manager';\nimport { InteractiveComponent } from './interactive-component';\n\nexport abstract class StatefulComponent<\n  TState extends ComponentState = ComponentState,\n  TEventMap extends AppEventMap = AppEventMap,\n> extends InteractiveComponent<TEventMap> {\n  protected state: TState;\n  protected stateConfigs: Map<keyof TState, ComponentStateConfig> = new Map();\n  protected stateManager: StateManager;\n  protected storageManager: StorageManager;\n  protected persistenceManager: PersistenceManager;\n  private statePrefix: string;\n  private initialState: Partial<TState> = {};\n\n  constructor(props: StatefulComponentProps = {}) {\n    super(props);\n\n    this.state = {} as TState;\n    this.stateManager = StateManager.getInstance();\n    this.storageManager = StorageManager.getInstance();\n    this.persistenceManager = PersistenceManager.getInstance();\n    this.statePrefix = props.statePrefix || this.id;\n\n    // Configure state from config\n    if (props.state) {\n      const configs = Array.isArray(props.state) ? props.state : [props.state];\n      configs.forEach((stateConfig) => this.configureState(stateConfig));\n    }\n  }\n\n  /**\n   * Initialize component and restore state\n   */\n  protected override async onInit(): Promise<void> {\n    await super.onInit();\n\n    // Restore state from storage\n    this.restoreState();\n\n    // Subscribe to global state changes if using StateManager\n    this.subscribeToStateChanges();\n  }\n\n  /**\n   * Save state before destroying\n   */\n  protected override async onDestroy(): Promise<void> {\n    // Persist state if configured\n    if ((this.props as StatefulComponentProps).persistState) {\n      this.persistState();\n    }\n\n    await super.onDestroy();\n  }\n\n  /**\n   * Configure a state property\n   */\n  protected configureState(config: ComponentStateConfig): void {\n    const key = config.key as keyof TState;\n    this.stateConfigs.set(key, config);\n\n    // Set default value\n    if (config.defaultValue !== undefined) {\n      this.state[key] = config.defaultValue as TState[keyof TState];\n      this.initialState[key] = config.defaultValue as TState[keyof TState];\n    }\n  }\n\n  /**\n   * Get state value\n   */\n  public getState<K extends keyof TState>(key: K): TState[K] {\n    return this.state[key];\n  }\n\n  /**\n   * Set state value with validation and change tracking\n   */\n  public setState<K extends keyof TState>(\n    key: K,\n    value: TState[K],\n    options: { silent?: boolean; persist?: boolean } = {}\n  ): boolean {\n    const from = this.state[key];\n\n    // Skip if value hasn't changed\n    if (this.isEqual(from, value)) {\n      return false;\n    }\n\n    const config = this.stateConfigs.get(key);\n\n    // Validate if validator provided\n    if (config?.validate && !config.validate(value as StateValue)) {\n      this.logWarn(`State validation failed for ${String(key)}:`, value);\n      return false;\n    }\n\n    // Transform if transformer provided\n    const transformedValue = config?.transform\n      ? (config.transform(value as StateValue) as TState[K])\n      : value;\n\n    // Update state\n    this.state[key] = transformedValue;\n\n    // Persist if configured\n    if (options.persist !== false) {\n      this.persistStateKey(key, transformedValue);\n    }\n\n    // Emit change event\n    if (!options.silent) {\n      this.onStateChange(key, from, transformedValue);\n    }\n\n    return true;\n  }\n\n  /**\n   * Batch update multiple state values\n   */\n  public setStates(\n    updates: Partial<TState>,\n    options: { silent?: boolean; persist?: boolean } = {}\n  ): void {\n    const changes: Array<{ key: keyof TState; from: StateValue; to: StateValue }> = [];\n\n    Object.entries(updates).forEach(([key, value]) => {\n      const typedKey = key as keyof TState;\n      const from = this.state[typedKey];\n\n      if (this.setState(typedKey, value as TState[keyof TState], { ...options, silent: true })) {\n        changes.push({ key: typedKey, from, to: value });\n      }\n    });\n\n    // Emit batch change event\n    if (!options.silent && changes.length > 0) {\n      this.logDebug(`Batch state change`, { changes });\n      changes.forEach(({ key, from, to }) => {\n        this.onStateChange(key, from, to);\n      });\n    }\n  }\n\n  /**\n   * Reset state to initial values\n   */\n  protected resetState(keys?: Array<keyof TState>): void {\n    const keysToReset = keys || (Object.keys(this.state) as Array<keyof TState>);\n\n    keysToReset.forEach((key) => {\n      if (key in this.initialState) {\n        this.setState(key, this.initialState[key] as TState[keyof TState]);\n      }\n    });\n  }\n\n  /**\n   * Get all current state\n   */\n  public getAllState(): Readonly<TState> {\n    return { ...this.state };\n  }\n\n  /**\n   * Subscribe to global state changes\n   */\n  private subscribeToStateChanges(): void {\n    // Subscribe to state changes that match our prefix\n    this.subscribe('state:changed', (payload) => {\n      if (payload.key.startsWith(this.statePrefix)) {\n        const localKey = payload.key.replace(`${this.statePrefix}.`, '') as keyof TState;\n        if (localKey in this.state) {\n          this.setState(localKey, payload.to as TState[keyof TState], {\n            silent: false,\n            persist: false,\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * Called when state changes\n   */\n  protected onStateChange(key: keyof TState, from: StateValue, to: StateValue): void {\n    // const event: StateChangeEvent = {\n    //   key: String(key),\n    //   from,\n    //   to,\n    //   component: this.id,\n    // };\n\n    // // Emit local state change\n    // this.emitCustom('state:changed', event);\n\n    // Emit to EventBus\n    this.emit('state:changed', {\n      key: `${this.statePrefix}.${String(key)}`,\n      from,\n      to,\n      timestamp: Date.now(),\n    });\n\n    // Call abstract handler\n    this.handleStateChange(key, from as TState[keyof TState], to as TState[keyof TState]);\n  }\n\n  /**\n   * Abstract method for child classes to handle state changes\n   */\n  protected abstract handleStateChange<K extends keyof TState>(\n    key: K,\n    from: TState[K],\n    to: TState[K]\n  ): void;\n\n  /**\n   * Persist a single state key\n   */\n  private persistStateKey<K extends keyof TState>(key: K, value: TState[K]): void {\n    const config = this.stateConfigs.get(key);\n    if (!config) return;\n\n    const persistConfig: PersistenceConfig = {\n      key: this.statePrefix,\n      storage: (config.storage || 'memory') as StorageType,\n      version: 1,\n    };\n\n    try {\n      this.persistenceManager.save(String(key), value, persistConfig);\n    } catch (error) {\n      this.logError(`Failed to persist state: ${String(key)}`, error);\n    }\n  }\n\n  /**\n   * Persist all state\n   */\n  private persistState(): void {\n    Object.entries(this.state).forEach(([key, value]) => {\n      this.persistStateKey(key as keyof TState, value as TState[keyof TState]);\n    });\n  }\n\n  /**\n   * Restore state from storage\n   */\n  private restoreState(): void {\n    this.stateConfigs.forEach((config, key) => {\n      const persistConfig: PersistenceConfig = {\n        key: this.statePrefix,\n        storage: (config.storage || 'memory') as StorageType,\n        version: 1,\n      };\n\n      try {\n        const storedValue = this.persistenceManager.load(String(key), persistConfig);\n        if (storedValue !== null) {\n          this.setState(key, storedValue as TState[keyof TState], {\n            silent: true,\n            persist: false,\n          });\n        }\n      } catch (error) {\n        this.logError(`Failed to restore state: ${String(key)}`, error);\n      }\n    });\n  }\n\n  /**\n   * Check if two values are equal\n   */\n  private isEqual(a: unknown, b: unknown): boolean {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (typeof a !== 'object' || typeof b !== 'object') return false;\n\n    // Simple deep equality check for objects\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    if (keysA.length !== keysB.length) return false;\n\n    return keysA.every((key) =>\n      this.isEqual((a as Record<string, unknown>)[key], (b as Record<string, unknown>)[key])\n    );\n  }\n\n  /**\n   * Create a computed property\n   */\n  protected createComputed<R>(\n    _dependencies: Array<keyof TState>,\n    compute: (state: TState) => R\n  ): () => R {\n    return () => compute(this.state);\n  }\n\n  /**\n   * Watch for state changes with a callback\n   */\n  protected watchState<K extends keyof TState>(\n    key: K,\n    callback: (current: TState[K], previous: TState[K]) => void\n  ): () => void {\n    const handler = (e: Event) => {\n      const { detail } = e as CustomEvent<StateChangeEvent>;\n      if (detail.key === String(key)) {\n        callback(detail.to as TState[K], detail.from as TState[K]);\n      }\n    };\n\n    this.rootElement?.addEventListener('state:changed', handler);\n\n    return () => {\n      this.rootElement?.removeEventListener('state:changed', handler);\n    };\n  }\n}\n", "export const ATTR = 'data-form';\n", "import type { FormBehavior } from '../types';\n\n/**\n * Valid transition types as a Record<TransitionType, true>\n * TypeScript enforces that all TransitionType values are present as keys\n */\nexport const VALID_BEHAVIOR_TYPE_MAP: Record<FormBehavior, true> = {\n  byField: true,\n  byGroup: true,\n  bySet: true,\n  byCard: true,\n} as const;\n", "import type { FormElementType } from '../types';\n\n/**\n * Valid element types as a Record<FormElementType, true>\n * TypeScript enforces that all FormElementType values are present as keys\n */\nexport const VALID_ELEMENT_TYPE_MAP: Record<FormElementType, true> = {\n  form: true,\n  card: true,\n  set: true,\n  group: true,\n  field: true,\n  input: true,\n  prev: true,\n  next: true,\n  submit: true,\n  error: true,\n  'progress-line': true,\n} as const;\n", "import type { ErrorDisplayMode } from '../types';\n\n/**\n * Valid error display types as a Record<ErrorDisplayMode, true>\n * TypeScript enforces that all ErrorDisplayMode values are present as keys\n */\nexport const VALID_ERROR_DISPLAY_TYPE_MAP: Record<ErrorDisplayMode, true> = {\n  native: true,\n} as const;\n", "import type { StorageType } from '../types';\n\n/**\n * Valid storage types as a Record<StorageType, true>\n * TypeScript enforces that all StorageType values are present as keys\n */\nexport const VALID_STORAGE_TYPE_MAP: Record<StorageType, true> = {\n  memory: true,\n} as const;\n", "import type { TransitionType } from '../types';\n\n/**\n * Valid transition types as a Record<TransitionType, true>\n * TypeScript enforces that all TransitionType values are present as keys\n */\nexport const VALID_TRANSITION_TYPE_MAP: Record<TransitionType, true> = {\n  fade: true,\n  slide: true,\n  none: true,\n} as const;\n", "import { ATTR } from 'src/form/constants';\n\nimport type { FlowupsForm } from '../..';\nimport type { ItemData } from '../../types';\n\n/**\n * Hierarchy Builder Utility\n *\n * Shared hierarchy building utilities for all managers.\n * Static methods - no instantiation needed.\n *\n * Extracted from ItemManager to be reusable by ButtonManager and other managers.\n */\nexport class HierarchyBuilder {\n  /**\n   * Build hierarchy object from parent item\n   * Recursively walks up parent chain\n   *\n   * This is the core method used by ItemManager.findParentHierarchy() to create\n   * hierarchy objects by recursively merging parent hierarchies:\n   *\n   * - CardParentHierarchy: { formId }\n   * - SetParentHierarchy: { ..., cardId, cardIndex }\n   * - GroupParentHierarchy: { ..., setId, setIndex }\n   * - FieldParentHierarchy: { ..., groupId, groupIndex }\n   * - InputParentHierarchy: { ..., fieldId, fieldIndex }\n   * - ButtonParentHierarchy: CardParentHierarchy | SetParentHierarchy | GroupParentHierarchy\n   *\n   * @param parent - Parent item or null\n   * @param formId - Form ID (required for all hierarchies)\n   * @returns Hierarchy object with parent IDs and indices\n   *\n   * @example\n   * // Building a FieldParentHierarchy from a group parent\n   * const groupItem = { id: 'group-1', index: 0, type: 'group', parentHierarchy: { formId: 'form', cardId: 'card-1', cardIndex: 0, setId: 'set-1', setIndex: 0 } };\n   * const hierarchy = HierarchyBuilder.buildFromParent(groupItem, 'form');\n   * // Returns: { formId: 'form', cardId: 'card-1', cardIndex: 0, setId: 'set-1', setIndex: 0, groupId: 'group-1', groupIndex: 0 }\n   */\n  static buildFromParent(parent: ItemData | undefined, formId: string): Record<string, unknown> {\n    const hierarchy: Record<string, unknown> = {\n      formId,\n    };\n\n    if (!parent) return hierarchy;\n\n    // Add this parent's info\n    hierarchy[`${parent.type}Id`] = parent.id;\n    hierarchy[`${parent.type}Index`] = parent.index;\n\n    // If parent has hierarchy, merge it (walks up the chain)\n    if ('parentHierarchy' in parent && parent.parentHierarchy) {\n      Object.assign(hierarchy, parent.parentHierarchy);\n    }\n\n    return hierarchy;\n  }\n\n  /**\n   * Find parent hierarchy for an element by walking up the DOM tree\n   *\n   * This method discovers all parent items (field, group, set, card) by:\n   * 1. Finding the immediate parent using findParentItem callback\n   * 2. Recursively building the full hierarchy using buildFromParent\n   *\n   * Used by ItemManager during item discovery to establish parent relationships.\n   *\n   * @param child - HTMLElement or ItemData to find parents for\n   * @param form - Form instance for accessing managers\n   * @param findParentItem - Callback to find immediate parent (manager-specific)\n   * @returns Complete hierarchy object\n   *\n   * @example\n   * // In FieldManager.findParentHierarchy()\n   * const hierarchy = HierarchyBuilder.findParentHierarchy<FieldParentHierarchy>(\n   *   fieldElement,\n   *   this.form,\n   *   (el) => this.findParentByElement(el, 'group', () => this.form.groupManager.getAll())\n   * );\n   * // Returns: { formId, cardId, cardIndex, setId, setIndex, groupId, groupIndex }\n   */\n  static findParentHierarchy<THierarchy>(\n    child: HTMLElement | ItemData,\n    form: FlowupsForm,\n    findParentItem: (element: HTMLElement) => ItemData | undefined\n  ): THierarchy {\n    let parentItem: ItemData | undefined;\n\n    // If already an ItemData object, use it directly\n    if (child instanceof HTMLElement) {\n      // Find immediate parent using manager-specific logic\n      parentItem = findParentItem(child);\n    } else {\n      parentItem = child;\n    }\n\n    // Build complete hierarchy by walking up parent chain\n    return HierarchyBuilder.buildFromParent(parentItem, form.getId()) as THierarchy;\n  }\n\n  /**\n   * Generic helper to find parent item by selector\n   * @param child - The child element\n   * @param parentType - The parent type\n   * @param getParentItems - The function to get the parent items\n   * @returns The parent item or null\n   */\n  static findParentByElement<T extends ItemData>(\n    child: HTMLElement,\n    parentType: 'card' | 'set' | 'group' | 'field',\n    getParentItems: () => T[]\n  ): T | undefined {\n    const parentElement = child.closest(`[${ATTR}-element^=\"${parentType}\"]`);\n    if (!parentElement) return undefined;\n\n    const parents = getParentItems();\n    const parent = parents.find((parent) => parent.element === parentElement);\n\n    return parent;\n  }\n}\n", "import type { BaseItem } from 'src/form/types';\n\n/**\n * Shared storage and lookup utilities for items\n * Used by composition, not inheritance\n */\nexport class ItemStore<TItem extends BaseItem> {\n  private items: TItem[] = [];\n  private itemMap: Map<string, TItem> = new Map();\n\n  /** Add item to storage */\n  public add(item: TItem): void {\n    this.items.push(item);\n    this.itemMap.set(item.id, item);\n  }\n\n  /** Update item in storage */\n  public update(item: TItem): void {\n    this.itemMap.set(item.id, item);\n    this.items[item.index] = item;\n  }\n\n  /** Update item data by merging */\n  public merge(item: TItem, data: Partial<TItem>): void {\n    const updated = { ...item, ...data };\n    this.update(updated);\n  }\n\n  /** Get all items */\n  public getAll(): TItem[] {\n    return this.items;\n  }\n\n  /** Get by ID */\n  public getById(id: string): TItem | undefined {\n    return this.itemMap.get(id);\n  }\n\n  /** Get by index */\n  public getByIndex(index: number): TItem | undefined {\n    return this.items.find((item) => item.index === index);\n  }\n\n  /** Get by selector (ID or index) */\n  public getBySelector(selector: string | number): TItem | undefined {\n    return typeof selector === 'string' ? this.getById(selector) : this.getByIndex(selector);\n  }\n\n  /** Get by DOM */\n  public getByDOM(dom: HTMLElement): TItem | undefined {\n    return this.items.find((item) => item.element === dom);\n  }\n\n  /** Filter items by predicate */\n  public filter(predicate: (item: TItem) => boolean): TItem[] {\n    return this.items.filter(predicate);\n  }\n\n  /** Filter items by predicate */\n  public find(predicate: (item: TItem) => boolean): TItem | undefined {\n    return this.items.find(predicate);\n  }\n\n  /** Clear all items */\n  public clear(): void {\n    this.items = [];\n    this.itemMap.clear();\n  }\n\n  /** Get count */\n  public get length(): number {\n    return this.items.length;\n  }\n}\n", "/**\n * ID Generator\n *\n * Generate kebab-case IDs from titles.\n */\n\n/**\n * Generate ID from title\n *\n * Converts title to kebab-case ID\n *\n * @param title - The title string\n * @returns Kebab-case ID\n *\n * @example\n * generateIdFromTitle('Contact Details') // \"contact-details\"\n * generateIdFromTitle('Personal Info') // \"personal-info\"\n */\nexport function generateIdFromTitle(title: string): string {\n  return title\n    .toLowerCase()\n    .trim()\n    .replace(/[^\\w\\s-]/g, '') // Remove special characters\n    .replace(/\\s+/g, '-') // Replace spaces with hyphens\n    .replace(/-+/g, '-') // Replace multiple hyphens with single\n    .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens\n}\n", "/**\n * Title Extractor\n *\n * Extract titles from elements with priority resolution.\n */\n\nimport { ATTR } from '../../constants/attr';\nimport type { TitleExtractionResult } from '../../types/config';\nimport { generateIdFromTitle } from './generate-id-from-title';\n\n/**\n * Extract title from <legend> element\n *\n * Used for sets and groups that use <fieldset>\n *\n * @param element - The element to search within\n * @returns Legend text content or null\n *\n * @example\n * extractTitleFromLegend(setElement) // \"Contact Details\"\n */\nexport function extractTitleFromLegend(element: HTMLElement): string | null {\n  const legend = element.querySelector('legend');\n  return legend?.textContent?.trim() || null;\n}\n\n/**\n * Extract title with priority resolution\n *\n * Priority:\n * 1. Explicit title attribute (${ATTR}-{type}title)\n * 2. <legend> text content (for sets/groups)\n * 3. Combined syntax ID (${ATTR}-element=\"type:id\")\n * 4. Auto-generate from index\n *\n * @param element - The DOM element\n * @param elementType - Type of element (card, set, group)\n * @param combinedId - ID from combined syntax (if any)\n * @param index - Element index (for fallback)\n * @returns Title extraction result\n *\n * @example\n * extractTitle(setElement, 'set', undefined, 0)\n * // Returns: { title: 'Contact Details', source: 'legend', id: 'contact-details' }\n */\nexport function extractTitle(\n  element: HTMLElement,\n  elementType: 'card' | 'set' | 'group',\n  combinedId: string | undefined,\n  index: number\n): TitleExtractionResult {\n  // Priority 1: Explicit title attribute\n  const titleAttr = element.getAttribute(`${ATTR}-${elementType}title`);\n  if (titleAttr?.trim()) {\n    const title = titleAttr.trim();\n    return {\n      title,\n      source: 'attribute',\n      id: combinedId || generateIdFromTitle(title),\n    };\n  }\n\n  // Priority 2: <legend> text content (for sets and groups)\n  if (elementType === 'set' || elementType === 'group') {\n    const legendTitle = extractTitleFromLegend(element);\n    if (legendTitle) {\n      return {\n        title: legendTitle,\n        source: 'legend',\n        id: combinedId || generateIdFromTitle(legendTitle),\n      };\n    }\n  }\n\n  // Priority 3: Combined syntax ID\n  if (combinedId) {\n    // Convert ID to title (kebab-case to Title Case)\n    const title = combinedId\n      .split('-')\n      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n\n    return {\n      title,\n      source: 'attribute',\n      id: combinedId,\n    };\n  }\n\n  // Priority 4: Auto-generate from index\n  const generatedId = `${elementType}-${index}`;\n  const generatedTitle = `${elementType.charAt(0).toUpperCase() + elementType.slice(1)} ${\n    index + 1\n  }`;\n\n  return {\n    title: generatedTitle,\n    source: 'generated',\n    id: generatedId,\n  };\n}\n", "/**\n * Attribute Config Parser\n *\n * Parse all ${ATTR}* attributes from an element with compile-time type safety.\n * No manual key lists needed - TypeScript validates keys automatically!\n */\n\nimport { ATTR } from 'src/form/constants';\n\nimport type { BaseAttributeConfig } from '../../types/config';\n\n/**\n * Get all ${ATTR}* attributes from element\n *\n * This version accepts ALL ${ATTR}* attributes and returns them as Partial<T>.\n * TypeScript will enforce type safety when you ACCESS the properties, not when parsing.\n *\n * @template T - The attribute config interface to use\n * @param element - The DOM element\n * @returns Parsed attribute configuration (all keys are optional)\n *\n * @example\n * const attrs = getConfigAttributes<FormAttributeConfig>(element);\n * // TypeScript knows: attrs.behavior is valid\n * // TypeScript errors: attrs.cardtitle (doesn't exist on FormAttributeConfig)\n */\nexport function getConfigAttributes<T extends BaseAttributeConfig>(\n  element: HTMLElement\n): Partial<T> {\n  const config: Record<string, string> = {};\n\n  // Get all data-f orm-* attributes\n  Array.from(element.attributes).forEach((attr) => {\n    if (attr.name.startsWith(`${ATTR}-`)) {\n      // Remove `${ATTR}-` prefix\n      const key = attr.name.replace(`${ATTR}-`, '');\n      config[key] = attr.value;\n    }\n  });\n\n  // TypeScript will validate property access based on T\n  return config as Partial<T>;\n}\n", "/**\n * Parse boolean attribute value\n *\n * @param value - Attribute value string\n * @param defaultValue - Default value if not set\n * @returns Boolean value\n *\n * @example\n * parseBooleanAttribute('true') // true\n * parseBooleanAttribute('false') // false\n * parseBooleanAttribute(undefined, true) // true\n */\nexport function parseBooleanAttribute(\n  value: string | undefined,\n  defaultValue: boolean = false\n): boolean {\n  if (value === undefined) return defaultValue;\n  return value === 'true' || value === '';\n}\n", "/**\n * Generic Type Validator\n *\n * Type-safe validation for any union type using a Record map.\n * Works with FormElementType, TransitionType, FormBehavior, etc.\n */\n\n/**\n * Check if a string is a valid type based on a type map\n *\n * This uses a Record lookup which is O(1) and type-safe.\n *\n * @template T - The union type to validate against\n * @param value - The value to check\n * @param typeMap - Record map of valid types (e.g., VALID_ELEMENT_TYPE_MAP)\n * @returns Type predicate indicating if value is a valid T\n *\n * @example\n * const elementType = element.getAttribute('${ATTR}-element');\n * if (isValidType(elementType, VALID_ELEMENT_TYPE_MAP)) {\n *   // TypeScript knows elementType is FormElementType here\n *   console.log(elementType);\n * }\n *\n * @example\n * const transition = element.getAttribute('${ATTR}-transition');\n * if (isValidType(transition, VALID_TRANSITION_TYPE_MAP)) {\n *   // TypeScript knows transition is TransitionType here\n *   config.transition = transition;\n * }\n */\nexport function isValidType<T extends string>(\n  value: string | null | undefined,\n  typeMap: Record<T, true>\n): value is T {\n  if (!value) return false;\n  return value in typeMap;\n}\n", "/**\n * Generic Type Assertion\n *\n * Assert that a value is a valid type, throws error if invalid.\n */\n\nimport { isValidType } from './is-valid-type';\n\n/**\n * Assert that a value is a valid type based on a type map\n * Throws an error if invalid\n *\n * @template T - The union type to validate against\n * @param value - The value to check\n * @param typeMap - Record map of valid types\n * @param typeName - Human-readable name for error message (e.g., \"element type\", \"transition\")\n * @param context - Optional context for error message\n * @throws Error if value is not a valid T\n *\n * @example\n * const elementType = assertValidType(\n *   element.getAttribute('${ATTR}-element'),\n *   VALID_ELEMENT_TYPE_MAP,\n *   'element type',\n *   'Card element'\n * );\n * // elementType is guaranteed to be FormElementType here\n *\n * @example\n * const behavior = assertValidType(\n *   attrs.behavior,\n *   VALID_BEHAVIOR_TYPE_MAP,\n *   'behavior'\n * );\n * // behavior is guaranteed to be FormBehavior here\n */\nexport function assertValidType<T extends string>(\n  value: string | null | undefined,\n  typeMap: Record<T, true>,\n  typeName: string,\n  context?: string\n): asserts value is T {\n  if (!isValidType(value, typeMap)) {\n    const validTypes = Object.keys(typeMap).join(', ');\n    const errorContext = context ? `${context}: ` : '';\n    throw new Error(\n      `${errorContext}Invalid ${typeName} \"${value}\". Valid types are: ${validTypes}`\n    );\n  }\n}\n", "/**\n * Behavior Type Validators\n *\n * Convenience wrappers for validating FormBehavior.\n */\n\nimport { VALID_BEHAVIOR_TYPE_MAP } from '../../constants';\nimport type { FormBehavior } from '../../types';\nimport { assertValidType } from './assert-valid-type';\nimport { getValidTypes } from './get-valid-types';\nimport { isValidType } from './is-valid-type';\n\n/**\n * Check if a string is a valid FormBehavior\n *\n * @param value - The value to check\n * @returns Type predicate indicating if value is a valid FormBehavior\n *\n * @example\n * const behavior = element.getAttribute('${ATTR}-behavior');\n * if (isValidBehaviorType(behavior)) {\n *   // TypeScript knows behavior is FormBehavior here\n *   config.behavior = behavior;\n * }\n */\nexport function isValidBehaviorType(value: string | null | undefined): value is FormBehavior {\n  return isValidType(value, VALID_BEHAVIOR_TYPE_MAP);\n}\n\n/**\n * Assert that a value is a valid FormBehavior\n * Throws an error if invalid\n *\n * @param value - The value to check\n * @param context - Optional context for error message\n * @throws Error if value is not a valid FormBehavior\n *\n * @example\n * const behavior = assertValidBehaviorType(attrs.behavior);\n * // behavior is guaranteed to be FormBehavior here\n */\nexport function assertValidBehaviorType(\n  value: string | null | undefined,\n  context?: string\n): asserts value is FormBehavior {\n  assertValidType(value, VALID_BEHAVIOR_TYPE_MAP, 'behavior type', context);\n}\n\n/**\n * Get all valid behavior types\n * Useful for error messages or documentation\n *\n * @returns Array of all valid FormBehavior values\n *\n * @example\n * const types = getValidBehaviorTypes();\n * // ['byField'] (v1.0 - more in future versions)\n */\nexport function getValidBehaviorTypes(): FormBehavior[] {\n  return getValidTypes(VALID_BEHAVIOR_TYPE_MAP);\n}\n", "/**\n * Element Type Validators\n *\n * Convenience wrappers for validating FormElementType.\n */\n\nimport { VALID_ELEMENT_TYPE_MAP } from '../../constants';\nimport type { FormElementType } from '../../types';\nimport { assertValidType } from './assert-valid-type';\nimport { getValidTypes } from './get-valid-types';\nimport { isValidType } from './is-valid-type';\n\n/**\n * Check if a string is a valid FormElementType\n *\n * @param value - The value to check\n * @returns Type predicate indicating if value is a valid FormElementType\n *\n * @example\n * const elementType = element.getAttribute('${ATTR}-element');\n * if (isValidElementType(elementType)) {\n *   // TypeScript knows elementType is FormElementType here\n *   console.log(elementType); // 'card' | 'set' | 'field' | etc.\n * }\n */\nexport function isValidElementType(value: string | null | undefined): value is FormElementType {\n  return isValidType(value, VALID_ELEMENT_TYPE_MAP);\n}\n\n/**\n * Assert that a value is a valid FormElementType\n * Throws an error if invalid\n *\n * @param value - The value to check\n * @param context - Optional context for error message\n * @throws Error if value is not a valid FormElementType\n *\n * @example\n * const elementType = assertValidElementType(\n *   element.getAttribute('${ATTR}-element'),\n *   'Card element'\n * );\n * // elementType is guaranteed to be FormElementType here\n */\nexport function assertValidElementType(\n  value: string | null | undefined,\n  context?: string\n): asserts value is FormElementType {\n  assertValidType(value, VALID_ELEMENT_TYPE_MAP, 'element type', context);\n}\n\n/**\n * Get all valid element types\n * Useful for error messages or documentation\n *\n * @returns Array of all valid FormElementType values\n *\n * @example\n * const types = getValidElementTypes();\n * // ['form', 'card', 'set', 'group', 'field', 'prev', 'next', 'submit', 'error']\n */\nexport function getValidElementTypes(): FormElementType[] {\n  return getValidTypes(VALID_ELEMENT_TYPE_MAP);\n}\n", "/**\n * Element Type Validators\n *\n * Convenience wrappers for validating FormElementType.\n */\n\nimport { VALID_ERROR_DISPLAY_TYPE_MAP } from 'src/form/constants';\n\nimport type { ErrorDisplayMode } from '../../types';\nimport { assertValidType } from './assert-valid-type';\nimport { getValidTypes } from './get-valid-types';\nimport { isValidType } from './is-valid-type';\n\n/**\n * Check if a string is a valid ErrorDisplayMode\n *\n * @param value - The value to check\n * @returns Type predicate indicating if value is a valid ErrorDisplayMode\n *\n * @example\n * const errorMode = element.getAttribute('${ATTR}-errormode');\n * if (isValidErrorModeType(errorMode)) {\n *   // TypeScript knows errorMode is ErrorDisplayMode here\n *   console.log(errorMode); // 'native'\n * }\n */\nexport function isValidErrorModeType(value: string | null | undefined): value is ErrorDisplayMode {\n  return isValidType(value, VALID_ERROR_DISPLAY_TYPE_MAP);\n}\n\n/**\n * Assert that a value is a valid ErrorDisplayMode\n * Throws an error if invalid\n *\n * @param value - The value to check\n * @param context - Optional context for error message\n * @throws Error if value is not a valid ErrorDisplayMode\n *\n * @example\n * const errorMode = assertValidErrorModeType(\n *   element.getAttribute('${ATTR}-errormode'),\n *   'Native error display mode'\n * );\n * // errorMode is guaranteed to be ErrorDisplayMode here\n */\nexport function assertValidErrorModeType(\n  value: string | null | undefined,\n  context?: string\n): asserts value is ErrorDisplayMode {\n  assertValidType(value, VALID_ERROR_DISPLAY_TYPE_MAP, 'error display mode', context);\n}\n\n/**\n * Get all valid error display modes\n * Useful for error messages or documentation\n *\n * @returns Array of all valid ErrorDisplayMode values\n *\n * @example\n * const types = getValidErrorModeTypes();\n * // ['native']\n */\nexport function getValidErrorModeTypes(): ErrorDisplayMode[] {\n  return getValidTypes(VALID_ERROR_DISPLAY_TYPE_MAP);\n}\n", "/**\n * Storage Type Validators\n *\n * Convenience wrappers for validating StorageType.\n */\n\nimport { VALID_STORAGE_TYPE_MAP } from '../../constants';\nimport type { StorageType } from '../../types';\nimport { assertValidType } from './assert-valid-type';\nimport { getValidTypes } from './get-valid-types';\nimport { isValidType } from './is-valid-type';\n\n/**\n * Check if a string is a valid StorageType\n *\n * @param value - The value to check\n * @returns Type predicate indicating if value is a valid StorageType\n *\n * @example\n * const storageType = element.getAttribute('${ATTR}-persist');\n * if (isValidStorageType(storageType)) {\n *   // TypeScript knows storageType is StorageType here\n *   config.persist = storageType;\n * }\n */\nexport function isValidStorageType(value: string | null | undefined): value is StorageType {\n  return isValidType(value, VALID_STORAGE_TYPE_MAP);\n}\n\n/**\n * Assert that a value is a valid StorageType\n * Throws an error if invalid\n *\n * @param value - The value to check\n * @param context - Optional context for error message\n * @throws Error if value is not a valid StorageType\n *\n * @example\n * const storageType = assertValidStorageType(attrs.persist);\n * // storageType is guaranteed to be StorageType here\n */\nexport function assertValidStorageType(\n  value: string | null | undefined,\n  context?: string\n): asserts value is StorageType {\n  assertValidType(value, VALID_STORAGE_TYPE_MAP, 'storage type', context);\n}\n\n/**\n * Get all valid storage types\n * Useful for error messages or documentation\n *\n * @returns Array of all valid StorageType values\n *\n * @example\n * const types = getValidStorageTypes();\n * // ['memory'] (v1.0 - more in future versions)\n */\nexport function getValidStorageTypes(): StorageType[] {\n  return getValidTypes(VALID_STORAGE_TYPE_MAP);\n}\n", "/**\n * Transition Type Validators\n *\n * Convenience wrappers for validating TransitionType.\n */\n\nimport { VALID_TRANSITION_TYPE_MAP } from '../../constants';\nimport type { TransitionType } from '../../types';\nimport { assertValidType } from './assert-valid-type';\nimport { getValidTypes } from './get-valid-types';\nimport { isValidType } from './is-valid-type';\n\n/**\n * Check if a string is a valid TransitionType\n *\n * @param value - The value to check\n * @returns Type predicate indicating if value is a valid TransitionType\n *\n * @example\n * const transition = element.getAttribute('${ATTR}-transition');\n * if (isValidTransitionType(transition)) {\n *   // TypeScript knows transition is TransitionType here\n *   config.transition = transition;\n * }\n */\nexport function isValidTransitionType(value: string | null | undefined): value is TransitionType {\n  return isValidType(value, VALID_TRANSITION_TYPE_MAP);\n}\n\n/**\n * Assert that a value is a valid TransitionType\n * Throws an error if invalid\n *\n * @param value - The value to check\n * @param context - Optional context for error message\n * @throws Error if value is not a valid TransitionType\n *\n * @example\n * const transition = assertValidTransitionType(attrs.transition);\n * // transition is guaranteed to be TransitionType here\n */\nexport function assertValidTransitionType(\n  value: string | null | undefined,\n  context?: string\n): asserts value is TransitionType {\n  assertValidType(value, VALID_TRANSITION_TYPE_MAP, 'transition type', context);\n}\n\n/**\n * Get all valid transition types\n * Useful for error messages or documentation\n *\n * @returns Array of all valid TransitionType values\n *\n * @example\n * const types = getValidTransitionTypes();\n * // ['fade', 'slide', 'none']\n */\nexport function getValidTransitionTypes(): TransitionType[] {\n  return getValidTypes(VALID_TRANSITION_TYPE_MAP);\n}\n", "/**\n * Element Attribute Parser\n *\n * Parse ${ATTR}-element attribute with combined or simple syntax.\n */\n\nimport type { ParsedElementData } from '../../types/config';\nimport { assertValidElementType } from '../validation';\n\n/**\n * Parse ${ATTR}-element attribute\n *\n * Supports combined syntax: \"card:intro\" or simple: \"card\"\n *\n * @param value - Attribute value\n * @returns Parsed element type and optional ID\n * @throws Error if element type is invalid\n *\n * @example\n * parseElementAttribute('card:intro') // { type: 'card', id: 'intro' }\n * parseElementAttribute('card') // { type: 'card', id: undefined }\n */\nexport function parseElementAttribute(value: string): ParsedElementData {\n  const trimmed = value.trim();\n\n  // Check for combined syntax (element:id)\n  if (trimmed.includes(':')) {\n    const parts = trimmed.split(':');\n    const type = parts[0].trim();\n\n    // Assert throws error with helpful message if invalid\n    assertValidElementType(type);\n\n    return {\n      type,\n      id: parts[1].trim(),\n    };\n  }\n\n  // Simple syntax (just element type)\n  // Assert throws error with helpful message if invalid\n  assertValidElementType(trimmed);\n\n  return {\n    type: trimmed,\n    id: undefined,\n  };\n}\n", "/**\n * Parse number attribute value\n *\n * @param value - Attribute value string\n * @param defaultValue - Default value if not set or invalid\n * @returns Number value\n *\n * @example\n * parseNumberAttribute('300') // 300\n * parseNumberAttribute('invalid', 500) // 500\n */\nexport function parseNumberAttribute(value: string | undefined, defaultValue: number): number {\n  if (value === undefined) return defaultValue;\n  const parsed = parseInt(value, 10);\n  return isNaN(parsed) ? defaultValue : parsed;\n}\n", "export const plural = (word: string, count: number): string => {\n  return count === 1 ? word : `${word}s`;\n};\n", "// Capitalise the first letter of a string\nexport const sentenceCase = (string: string): string => {\n  return string.toLowerCase().replace(/(^\\s*\\w)/g, (match) => match.toUpperCase());\n};\n", "import type { ComponentError } from '$lib/types';\n\nimport type { FlowupsForm } from '..';\n\nexport abstract class BaseManager {\n  public readonly form: FlowupsForm;\n\n  constructor(form: FlowupsForm) {\n    this.form = form;\n  }\n\n  abstract init(): void;\n\n  abstract destroy(): void;\n\n  /** Start console group (only in debug mode) */\n  protected groupStart(name: string, collapsed = true): void {\n    this.form.groupStart(name, collapsed);\n  }\n\n  /** End console group (only in debug mode) */\n  protected groupEnd(): void {\n    this.form.groupEnd();\n  }\n\n  /** Debug logging (only in debug mode) */\n  protected logDebug(...args: unknown[]): void {\n    this.form.logDebug(...args);\n  }\n\n  /** Warning logging */\n  protected logWarn(...args: unknown[]): void {\n    this.form.logWarn(...args);\n  }\n\n  /** Error logging */\n  protected logError(...args: unknown[]): void {\n    this.form.logError(...args);\n  }\n\n  /** Table logging */\n  protected logTable(data: unknown[], columns?: string[]): void {\n    this.form.logTable(data, columns);\n  }\n\n  /** Create error */\n  protected createError(\n    message: string,\n    phase: 'init' | 'runtime' | 'destroy' = 'runtime',\n    cause?: unknown\n  ): ComponentError {\n    return this.form.createError(message, phase, cause);\n  }\n}\n", "import { ATTR } from '../constants';\nimport type {\n  ButtonItem,\n  ButtonParentElement,\n  ButtonParentHierarchy,\n  ButtonType,\n  SubmitRequestedEvent,\n} from '../types';\nimport { HierarchyBuilder, ItemStore, parseElementAttribute, sentenceCase } from '../utils';\nimport { BaseManager } from './base-manager';\n\n/**\n * ButtonManager Implementation\n *\n * Discover buttons within the form hierarchy.\n * Implements lazy event binding - only the active buttons are bound to events.\n */\nexport class ButtonManager extends BaseManager {\n  private store = new ItemStore<ButtonItem>();\n\n  /** Active event listeners for cleanup */\n  private activeListeners: Array<{\n    button: HTMLButtonElement;\n    index: number;\n    type: ButtonType;\n    event: 'click';\n    handler: EventListener;\n  }> = [];\n\n  /**\n   * Initialize the manager\n   */\n  public init(): void {\n    this.groupStart(`Initializing Buttons`);\n    this.discoverItems();\n    this.setupEventListeners();\n    this.applyStates(true);\n\n    this.logDebug('Initialized');\n    this.groupEnd();\n  }\n\n  /**\n   * Cleanup manager resources\n   */\n  public destroy(): void {\n    this.store.clear();\n    this.unbindAllButtons();\n\n    this.logDebug('ButtonManager destroyed');\n  }\n\n  // ============================================\n  // Discovery\n  // ============================================\n\n  /**\n   * Discover all navigation buttons in the form\n   * Finds buttons with [data-form-element=\"prev\"], [data-form-element=\"next\"], [data-form-element=\"submit\"]\n   */\n  public discoverItems(): void {\n    const rootElement = this.form.getRootElement();\n    if (!rootElement) {\n      throw this.form.createError(\n        'Cannot discover navigation buttons: root element is null',\n        'init',\n        {\n          cause: rootElement,\n        }\n      );\n    }\n\n    // Query all buttons\n    const items = this.form.queryAll<HTMLElement>(\n      `[${ATTR}-element=\"prev\"], [${ATTR}-element=\"next\"], [${ATTR}-element=\"submit\"]`\n    );\n\n    this.store.clear();\n\n    items.forEach((item, index) => {\n      const itemData = this.createItemData(item, index);\n      if (!itemData) return;\n\n      this.store.add(itemData);\n    });\n\n    this.logDebug(`Discovered ${this.store.length} buttons`);\n  }\n\n  private createItemData(element: HTMLElement, index: number): ButtonItem | undefined {\n    if (!(element instanceof HTMLElement)) return;\n\n    const attrValue = element.getAttribute(`${ATTR}-element`);\n    if (!attrValue) return;\n\n    const parsed = parseElementAttribute(attrValue);\n\n    // Skip if not prev, next or submit\n    if (!['prev', 'next', 'submit'].includes(parsed.type)) return;\n\n    /**\n     * Button is hopefully the element with attribute applied\n     * Otherwise, check if there's a button inside\n     * Otherwise, check if there's a link inside\n     * Otherwise throw an error\n     */\n    const button =\n      element instanceof HTMLButtonElement\n        ? element\n        : (element.querySelector<HTMLButtonElement>(`button`) ??\n          element.querySelector<HTMLAnchorElement>('a'));\n\n    if (!button) {\n      throw this.form.createError('Cannot discover navigation buttons: button is null', 'init', {\n        cause: element,\n      });\n    }\n\n    if (button instanceof HTMLAnchorElement) {\n      throw this.form.createError('Cannot discover navigation buttons: button is a link', 'init', {\n        cause: element,\n      });\n    }\n\n    const id = `${parsed.type}-button-${index}`;\n\n    // Create button item object\n    return this.buildItemData({\n      element,\n      index,\n      id,\n      active: false, // Calculated\n      type: parsed.type as ButtonType,\n      parentHierarchy: this.findParentHierarchy(element),\n      button,\n      originalText: this.getText(button),\n      disabled: true, // Calculated\n      visible: false, // Calculated\n    });\n  }\n\n  /**\n   * Build button item data\n   * Used during discovery and state updates\n   * Single source of truth for button data calculation\n   */\n  private buildItemData(item: ButtonItem): ButtonItem {\n    const active = this.determineActive(item.element);\n    // const visible = this.determineVisible(item.type);\n    const visible = true;\n    const enabled = this.determineEnabled(item.type, active && visible);\n\n    return {\n      ...item,\n      active,\n      visible,\n      disabled: !enabled,\n    };\n  }\n\n  /**\n   * Determine if item should be active based on parent and behavior\n   * Default implementation - can be overridden if needed\n   *\n   * @param element - HTMLElement to check\n   * @returns Whether element should be active\n   */\n  protected determineActive(element: HTMLElement): boolean {\n    // Get parent based on element type\n    const parent = this.findParentItem(element);\n    return parent ? parent.active : true;\n  }\n\n  /**\n   * Determine whether a button should be visible\n   * - Need to get the parent hierarchy\n   * - Check if parent Id is the currently active Card/Set\n   */\n  private determineVisible(type: ButtonType): boolean {\n    const { current, total } = this.getRelevantState();\n    const { currentCardIndex, totalCards, currentSetIndex, totalSets } = this.form.getAllState();\n\n    switch (type) {\n      case 'prev':\n        return (totalCards > 0 && currentCardIndex > 0) || (totalSets > 0 && currentSetIndex > 0);\n      case 'next':\n        return current !== total - 1;\n      case 'submit':\n        return current === total - 1;\n    }\n  }\n\n  private determineEnabled(type: ButtonType, activeAndVisible: boolean = true): boolean {\n    if (!activeAndVisible) return false;\n\n    const valid = this.form.inputManager\n      .getByFilter((input) => input.active && input.isIncluded)\n      .every((input) => input.isValid);\n\n    // const { current, total } = this.getRelevantState();\n\n    switch (type) {\n      case 'prev':\n        return activeAndVisible;\n      case 'next':\n        return valid;\n      case 'submit':\n        return valid;\n    }\n  }\n\n  private getRelevantState(): { current: number; total: number } {\n    const behavior = this.form.getBehavior();\n    const state = this.form.getAllState();\n\n    let current: number;\n    let total: number;\n\n    switch (behavior) {\n      case 'byField':\n        current = state.currentFieldIndex;\n        total = state.totalFields;\n        break;\n      case 'byGroup':\n        current = state.currentGroupIndex;\n        total = state.totalGroups;\n        break;\n      case 'bySet':\n        current = state.currentSetIndex;\n        total = state.totalSets;\n        break;\n      case 'byCard':\n        current = state.currentCardIndex;\n        total = state.totalCards;\n        break;\n      default:\n        throw this.form.createError(\n          'Cannot determine button visibility: invalid behavior',\n          'init',\n          { cause: behavior }\n        );\n    }\n\n    return { current, total };\n  }\n\n  private findParentHierarchy(child: HTMLElement): ButtonParentHierarchy {\n    return HierarchyBuilder.findParentHierarchy<ButtonParentHierarchy>(\n      child,\n      this.form,\n      (element) => this.findParentItem(element)\n    );\n  }\n\n  /**\n   * Find the parent item for a field\n   *\n   * @param element - The field element\n   * @returns Parent data or null\n   */\n  protected findParentItem(element: HTMLElement): ButtonParentElement | undefined {\n    const parentSet = HierarchyBuilder.findParentByElement(element, 'set', () =>\n      this.form.setManager.getAll()\n    );\n\n    const parentCard = HierarchyBuilder.findParentByElement(element, 'card', () =>\n      this.form.cardManager.getAll()\n    );\n\n    return parentSet ?? parentCard;\n  }\n\n  /**\n   * Setup event listeners for button clicks\n   */\n  private setupEventListeners(): void {\n    this.bindActiveButtons();\n\n    this.form.subscribe('form:navigation:changed', () => {\n      this.calculateStates();\n      this.applyStates();\n      this.handleActiveButtons();\n    });\n\n    this.form.subscribe('form:input:changed', () => {\n      this.calculateStates();\n      this.applyStates();\n    });\n\n    this.form.subscribe('form:condition:evaluated', () => {\n      this.calculateStates();\n      this.applyStates();\n    });\n\n    this.logDebug('Event listeners setup');\n  }\n\n  // ============================================\n  // Bind Listeners\n  // ============================================\n\n  /**\n   * Bind events to the current buttons\n   */\n  public bindActiveButtons(): void {\n    const activeItems = this.getActive();\n    if (activeItems.length === 0) return;\n\n    activeItems.forEach((item) => {\n      const { button } = item;\n\n      // If already bound, skip\n      const alreadyBound = this.activeListeners.some((listener) => listener.button === button);\n      if (alreadyBound) return;\n\n      // Bind event to button\n      const handler: EventListener = () => {\n        this.handleClick(item.type);\n      };\n\n      button.addEventListener('click', handler);\n      this.activeListeners.push({\n        button,\n        index: item.index,\n        type: item.type,\n        event: 'click',\n        handler,\n      });\n\n      const parent = this.findParentItem(item.element);\n      if (!parent) return;\n\n      this.logDebug(\n        `Bound \"click\" events to \"${item.type}\" button within ${parent.type} \"${parent.id}\"`\n      );\n    });\n  }\n\n  /**\n   * Unbind all inactive button listeners\n   * @internal Used during cleanup\n   */\n  private unbindInactiveButtons(): void {\n    const activeItems = this.getActive();\n    if (activeItems.length === 0) return;\n\n    this.activeListeners = this.activeListeners.filter((listener) => {\n      const shouldRemove = !activeItems.find((item) => item.index === listener.index);\n\n      if (shouldRemove) {\n        listener.button.removeEventListener(listener.event, listener.handler);\n\n        const parent = this.findParentItem(listener.button);\n        if (parent) {\n          this.logDebug(\n            `Unbound \"${listener.event}\" events from \"${listener.type}\" button within ${parent.type} \"${parent.id}\"`\n          );\n        }\n      }\n\n      return !shouldRemove; // Keep listeners that should NOT be removed\n    });\n  }\n\n  /**\n   * Unbind all button listeners\n   * @internal Used during cleanup\n   */\n  private unbindAllButtons(): void {\n    this.activeListeners.forEach((listener) => {\n      listener.button.removeEventListener(listener.event, listener.handler);\n    });\n    this.activeListeners = [];\n  }\n\n  // ============================================\n  // Button Click Handlers\n  // ============================================\n\n  /**\n   * Handle button clicks\n   */\n  private handleClick = (type: 'prev' | 'next' | 'submit'): void => {\n    if (type === 'submit') {\n      /** @update submit event and payload */\n      const payload: SubmitRequestedEvent = {};\n      this.logDebug('Submit button clicked: requesting form submission');\n      this.form.emit('form:submit:request', payload);\n      return;\n    }\n\n    this.logDebug(`${sentenceCase(type)} button clicked: requesting navigation`);\n    this.form.emit('form:navigation:request', { type });\n  };\n\n  // ============================================\n  // Button State Management\n  // ============================================\n\n  private calculateStates(): void {\n    this.getAll().forEach((item) => {\n      const updated = this.buildItemData(item);\n      this.store.update(updated);\n    });\n  }\n\n  /**\n   * Handle context change\n   */\n  private handleActiveButtons(): void {\n    this.unbindInactiveButtons();\n    this.bindActiveButtons();\n  }\n\n  /**\n   * Update button states based on current navigation position\n   * Called after state changes\n   */\n  public applyStates(isInitial: boolean = false): void {\n    this.logDebug(`${isInitial ? 'Initializing' : 'Updating'} button states`);\n\n    this.getAll().forEach((item) => {\n      item.button.disabled = item.disabled;\n      if (item.visible) {\n        item.element.style.removeProperty('display');\n      } else {\n        item.element.style.display = 'none';\n      }\n    });\n  }\n\n  // ============================================\n  // Private Helpers\n  // ============================================\n\n  /** Get all button elements */\n  private getAll(): ButtonItem[] {\n    return this.store.getAll();\n  }\n\n  /** Get by type */\n  private getByType(type: ButtonType): ButtonItem[] {\n    return this.store.filter((item) => item.type === type);\n  }\n\n  /** Get active */\n  private getActive(): ButtonItem[] {\n    return this.store.filter((button) => button.active && button.visible);\n  }\n\n  /** Get all buttons by parent */\n  private getAllByParent(parentHierarchy: ButtonParentHierarchy): ButtonItem[] {\n    return this.store.filter((item) => item.parentHierarchy === parentHierarchy);\n  }\n\n  /** Get all buttons of type by parent*/\n  private getTypeByParent(parentHierarchy: ButtonParentHierarchy, type: ButtonType): ButtonItem[] {\n    const allByParent = this.getAllByParent(parentHierarchy);\n    return allByParent.filter((button) => button.type === type);\n  }\n\n  /** Get the button text */\n  private getText(element: HTMLElement): string {\n    const textElement = element.querySelector(`[${ATTR}-element=\"button-text\"]`);\n    if (!textElement) return element.textContent ?? '';\n    return textElement.textContent ?? '';\n  }\n\n  // ============================================\n  // Public Helpers\n  // ============================================\n\n  /** Set the button text */\n  public setText(element: HTMLElement, text?: string): void {\n    const itemElement = element.dataset.button\n      ? element\n      : element.closest<HTMLElement>('[data-button]');\n    if (!itemElement) return;\n\n    const item = this.store.getByDOM(itemElement);\n    const setText = text ?? item?.originalText ?? '';\n    if (!setText) return;\n\n    const textElement = itemElement.querySelector(`[${ATTR}-element=\"button-text\"]`);\n    if (!textElement) element.textContent = setText;\n    else textElement.textContent = setText;\n  }\n\n  /** Get the submit button */\n  public getSubmit(): ButtonItem | undefined {\n    return this.store.getAll().find((item) => item.active && item.type === 'submit');\n  }\n\n  /**  */\n  public determineNextOrSubmit(): 'next' | 'submit' {\n    const active = this.getActive();\n\n    const next = active.find((button) => button.type === 'next');\n    if (next) {\n      this.logDebug('Next button found');\n      return 'next';\n    }\n\n    const submit = active.find((button) => button.type === 'submit');\n    if (submit) {\n      this.logDebug('Submit button found');\n      return 'submit';\n    }\n\n    return 'next';\n  }\n}\n", "import { ATTR } from '../constants';\nimport type {\n  CardParentHierarchy,\n  FormBehavior,\n  ItemData,\n  StateForItem,\n  UpdatableItemData,\n} from '../types';\nimport { HierarchyBuilder, ItemStore, plural } from '../utils';\nimport { BaseManager } from './base-manager';\n\n/**\n * Abstract ItemManager class\n * Provides common functionality for all item managers\n */\nexport abstract class ItemManager<TItem extends ItemData> extends BaseManager {\n  protected store = new ItemStore<TItem>();\n  protected abstract readonly itemType: string;\n  protected navigationOrder: number[] = [];\n\n  // ============================================\n  // Abstract Methods\n  // ============================================\n\n  protected abstract buildItemData(item: TItem): TItem;\n  protected abstract createItemData(element: HTMLElement, index: number): TItem | undefined;\n  public abstract calculateStates(): StateForItem<TItem>;\n  protected abstract findParentItem(element: HTMLElement): ItemData | undefined;\n\n  // ============================================\n  // Lifecycle Methods\n  // ============================================\n\n  public init(runOnInitalzed: boolean = true): void {\n    this.groupStart(`Initializing ${this.itemType}s`);\n    this.discoverItems();\n    if (this.itemType !== 'input') this.buildNavigationOrder();\n    this.setStates();\n\n    if (runOnInitalzed) this.onInitialized();\n  }\n\n  public onInitialized(): void {\n    this.logDebug(`Initialized`, { items: this.getAll() });\n    this.groupEnd();\n  }\n\n  public destroy(): void {\n    this.clear();\n\n    this.logDebug(`${this.constructor.name} destroyed`);\n  }\n\n  // ============================================\n  // Implemented Methods\n  // ============================================\n\n  /**\n   * Discover all items of this type in the form\n   * Finds all items with [${ATTR}-item^=\"${this.itemType}\"]\n   */\n  protected discoverItems(): void {\n    const rootElement = this.form.getRootElement();\n    if (!rootElement) {\n      throw this.createError(\n        `Cannot discover ${this.itemType}s: root element is undefined`,\n        'init',\n        {\n          cause: { manager: this.constructor.name, rootElement },\n        }\n      );\n    }\n\n    // Query all items of this type\n    const items = this.form.queryAll(`[${ATTR}-element^=\"${this.itemType}\"]`);\n\n    this.clear();\n\n    items.forEach((item, index) => {\n      const itemData = this.createItemData(item, index);\n      if (!itemData) return;\n\n      this.add(itemData);\n    });\n\n    this.logDebug(`Discovered ${items.length} ${plural(this.itemType, items.length)}`, {\n      items,\n    });\n  }\n\n  /**\n   * Update item data\n   * TypeScript ensures only valid properties for this item type\n   */\n  public updateItemData(\n    selector: string | number,\n    data: UpdatableItemData<TItem> = {} as UpdatableItemData<TItem>\n  ): void {\n    if (\n      (typeof selector === 'number' && selector < 0) ||\n      (typeof selector === 'number' && selector >= this.length)\n    )\n      return;\n\n    const item = this.getBySelector(selector);\n    if (!item) {\n      this.logWarn(`Cannot update ${this.itemType} data: ${selector} not found`);\n      return;\n    }\n\n    // Merge data with existing item data\n    const updated = this.mergeItemData(item, data);\n    this.update(updated);\n  }\n\n  /**\n   * Merge item data - can be overridden\n   * @virtual\n   */\n\n  protected mergeItemData(item: TItem, data: UpdatableItemData<TItem>): TItem {\n    const builtItem = this.buildItemData(item);\n    return {\n      ...builtItem,\n      visited: true, // Always mark as visited when updated\n      ...data,\n    } as TItem;\n  }\n\n  /**\n   * Rebuild item using buildItemData()\n   * Ensures item data is fresh before calculating state\n   */\n  public rebuildItem(item: TItem): void {\n    const rebuilt = this.buildItemData(item);\n    this.update(rebuilt);\n  }\n\n  /**\n   * Rebuild all items using buildItemData()\n   * Ensures item data is fresh before calculating state\n   */\n  public rebuildActive(): void {\n    const active = this.getActive();\n    if (active.length === 0) return;\n\n    active.forEach((item) => {\n      const rebuilt = this.buildItemData(item);\n      this.update(rebuilt);\n    });\n  }\n\n  /**\n   * Rebuild all items using buildItemData()\n   * Ensures item data is fresh before calculating state\n   */\n  public rebuildAll(): void {\n    this.getAll().forEach((item) => {\n      this.rebuildItem(item);\n    });\n  }\n\n  /**\n   * Determine if item should be active based on parent and behavior\n   * Default implementation - can be overridden if needed\n   *\n   * @param element - HTMLElement to check\n   * @param index - Element index\n   * @returns Whether element should be active\n   * @virtual\n   */\n  protected determineActive(element: HTMLElement, index: number): boolean {\n    const behavior = this.form.getBehavior();\n\n    // Get parent based on element type\n    const parent = this.findParentItem(element);\n\n    // No parent - first element is active\n    if (!parent) return index === 0;\n\n    // Behavior determines if only first child is active\n    const behaviorRequiresFirstOnly = this.behaviorRequiresFirstChild(behavior);\n\n    return behaviorRequiresFirstOnly ? parent.active && index === 0 : parent.active;\n  }\n\n  /**\n   * Check if current behavior requires only first child to be active\n   * Can be overwritten for item-specific behavior\n   * @virtual\n   */\n  protected behaviorRequiresFirstChild(behavior: FormBehavior): boolean {\n    const firstChildBehaviors: Record<FormBehavior, string[]> = {\n      byField: ['field', 'group', 'set', 'card'],\n      byGroup: ['group', 'set', 'card'],\n      bySet: ['set', 'card'],\n      byCard: ['card'],\n    };\n\n    return firstChildBehaviors[behavior]?.includes(this.itemType) ?? false;\n  }\n\n  /**\n   * Get all active item indices\n   * Returns array of indices for all items marked as active\n   * Used by calculateStates() to populate active*Indices arrays\n   *\n   * @returns Array of active item indices\n   */\n  protected getActiveIndices(): number[] {\n    return this.getByFilter((item) => item.active).map((item) => item.index);\n  }\n\n  /**\n   * Set an item as current (focused/primary)\n   * Automatically clears current flag from all other items\n   * Validates that the item is active before setting as current\n   *\n   * @param selector - Item ID or index\n   * @throws Warning if item is not active\n   */\n  public setCurrent(selector: string | number): void {\n    const item = this.getBySelector(selector);\n    if (!item) {\n      this.logWarn(`Cannot set current: ${this.itemType} not found`, { selector });\n      return;\n    }\n\n    // Validate: current item must be active\n    if (!item.active) {\n      this.logWarn(`Cannot set current: ${this.itemType} is not active`, {\n        id: item.id,\n        index: item.index,\n      });\n\n      return;\n    }\n\n    // Clear current flag from current item\n    this.clearCurrent();\n    this.updateItemData(item.index, { current: true } as UpdatableItemData<TItem>);\n\n    this.logDebug(`Set ${this.itemType} \"${item.id}\" as current`);\n  }\n\n  /**\n   * Clear current flag from all items\n   */\n  public clearCurrent(): void {\n    const items = this.getByFilter((item) => item.current);\n    if (items.length === 0) return;\n\n    items.forEach((item) => {\n      this.updateItemData(item.index, { current: false } as UpdatableItemData<TItem>);\n    });\n\n    this.logDebug(\n      `Cleared current flag from ${items.length} ${plural(this.itemType, items.length)}`\n    );\n  }\n\n  /**\n   * Clear all active and current flags\n   * Updates storage not states\n   */\n  public clearActiveAndCurrent(): void {\n    const items = this.getByFilter((item) => item.active || item.current);\n    if (items.length === 0) return;\n\n    items.forEach((item) => {\n      const updated = { ...item, active: false, current: false } as TItem;\n      this.update(updated);\n    });\n\n    this.logDebug(\n      `Cleared active and current flags from ${items.length} ${plural(this.itemType, items.length)}`\n    );\n  }\n\n  /**\n   * Set active flag\n   * Updates storage not states\n   */\n  public setActive(selector: string | number): void {\n    const item = this.getBySelector(selector);\n    if (!item) {\n      this.logWarn(`Cannot set active: ${this.itemType} not found`, { selector });\n      return;\n    }\n\n    const updated = { ...item, active: true } as TItem;\n    this.update(updated);\n\n    this.logDebug(`Set ${this.itemType} \"${item.id}\" as active`);\n  }\n\n  /**\n   * Set active by parent\n   * Updates storage not states\n   * @param parentId - The parent item ID\n   * @param parentType - The parent item type\n   * @param options - Active (boolean, defaults to true) and firstIsCurrent (boolean, defaults to false)\n   */\n  public setActiveByParent(\n    parentId: string,\n    parentType: 'card' | 'set' | 'group' | 'field',\n    options?: { firstIsCurrent?: boolean }\n  ): void {\n    const { firstIsCurrent = false } = options ?? {};\n\n    const children = this.getItemsByParentId(parentId, parentType);\n\n    children.forEach((item, index) => {\n      const builtItem = this.buildItemData(item);\n      const updated = {\n        ...builtItem,\n        active: true,\n        current: index === 0 && firstIsCurrent,\n      } as TItem;\n      this.update(updated);\n    });\n\n    this.logDebug(\n      `Set ${children.length} ${plural(this.itemType, children.length)} within ${parentType} \"${parentId}\" as active`\n    );\n  }\n\n  /**\n   * Get items by parent ID\n   * Uses type guards to safely access hierarchy properties\n   * @virtual\n   */\n  protected getItemsByParentId(\n    parentId: string,\n    parentType: 'card' | 'set' | 'group' | 'field'\n  ): TItem[] {\n    return this.getByFilter((item) => {\n      // Cards have no parent\n      if (item.type === 'card') return false;\n\n      const { parentHierarchy } = item;\n      if (!parentHierarchy) return false;\n\n      // Only Fields have groupId, Groups and Fields have setId, All items (except cards) have cardId\n      switch (parentType) {\n        case 'field':\n          return 'fieldId' in parentHierarchy && parentHierarchy.fieldId === parentId;\n        case 'group':\n          return 'groupId' in parentHierarchy && parentHierarchy.groupId === parentId;\n        case 'set':\n          return 'setId' in parentHierarchy && parentHierarchy.setId === parentId;\n        case 'card':\n          return 'cardId' in parentHierarchy && parentHierarchy.cardId === parentId;\n        default:\n          return false;\n      }\n    });\n  }\n\n  /**\n   * Generic helper to find parent item by selector\n   * @param child - The child element\n   * @param parentType - The parent type\n   * @param getParentItems - The function to get the parent items\n   * @returns The parent item or undefined\n   */\n  protected findParentByElement<T extends ItemData>(\n    child: HTMLElement,\n    parentType: string,\n    getParentItems: () => T[]\n  ): T | undefined {\n    const parentElement = child.closest(`[${ATTR}-element^=\"${parentType}\"]`);\n    if (!parentElement) return undefined;\n\n    const parents = getParentItems();\n    const parent = parents.find((parent) => parent.element === parentElement);\n\n    if (!parent) {\n      throw this.createError(`Cannot find parent ${parentType}: no parent item found`, 'init', {\n        cause: { child, parentElement },\n      });\n    }\n\n    return parent;\n  }\n\n  /**\n   * Find parent hierarchy for an item\n   * Builds hierarchy object by calling findParentItem recursively\n   *\n   * @param child - HTMLElement or parent item\n   * @returns Parent hierarchy object\n   * @throws If called on CardManager (cards have no parent hierarchy)\n   * @protected\n   */\n  protected findParentHierarchy<THierarchy extends CardParentHierarchy>(\n    child: HTMLElement | ItemData\n  ): THierarchy {\n    if (this.itemType === 'card') {\n      return { formId: this.form.getId() } as THierarchy;\n    }\n\n    // Use HierarchyBuilder\n    return HierarchyBuilder.findParentHierarchy<THierarchy>(child, this.form, (child) =>\n      this.findParentItem(child)\n    );\n  }\n\n  /**\n   * Build navigation order\n   *\n   * Creates array of item indexes in display order, skipping excluded\n   * To be called after discovery and whenever item visibility changes\n   */\n  public buildNavigationOrder(): void {\n    this.navigationOrder = this.getByFilter((item) =>\n      'isIncluded' in item ? item.isIncluded : true\n    ).map((item) => item.index);\n\n    // // reduce the navigation order array to say \"${index[0].id} --> ${index[1].id} --> ${index[2].id} --> ...\"\n    // const orderString = this.navigationOrder.reduce(\n    //   (acc, index) => {\n    //     if (index === 0) return acc;\n    //     const item = this.getByIndex(index);\n    //     return `${acc} --> ${item?.id}`;\n    //   },\n    //   `${this.getByIndex(0)?.id}`\n    // );\n\n    this.logDebug(`Navigation order built`);\n  }\n\n  /**\n   * Update item inclusion and rebuild navigation order\n   *\n   * @param itemId - Item ID\n   * @param isIncluded - Whether to include the item in the navigation order\n   */\n  public handleInclusion(id: string, isIncluded: boolean): void {\n    const item = this.getById(id);\n    if (!item) return;\n\n    // Type assertion needed because not all TItem types may have isIncluded at compile time\n    this.updateItemData(id, { isIncluded } as UpdatableItemData<TItem>);\n\n    // Rebuild navigation order (excludes items with isIncluded: false)\n    this.buildNavigationOrder();\n\n    this.logDebug(`${isIncluded ? 'Included' : 'Excluded'} ${this.itemType} \"${id}\"`);\n  }\n\n  // ============================================\n  // Expore Store Methods\n  // ============================================\n\n  /** Add item to store */\n  protected add(item: TItem): void {\n    this.store.add(item);\n  }\n\n  /** Update item in the store */\n  protected update(item: TItem): void {\n    this.store.update(item);\n  }\n\n  /** Merge item data */\n  protected merge(item: TItem, data: Partial<TItem>): void {\n    this.store.merge(item, data);\n  }\n\n  /** Clear store */\n  public clear(): void {\n    this.store.clear();\n  }\n\n  /** Get all items */\n  public getAll(): TItem[] {\n    return this.store.getAll();\n  }\n\n  /** Get item by id */\n  public getById(id: string): TItem | undefined {\n    return this.store.getById(id);\n  }\n\n  /** Get item by index */\n  public getByIndex(index: number): TItem | undefined {\n    return this.store.getByIndex(index);\n  }\n\n  /** Get item by selector (id or index) */\n  public getBySelector(selector: string | number): TItem | undefined {\n    return this.store.getBySelector(selector);\n  }\n\n  /** Get item by DOM */\n  public getByDOM(dom: HTMLElement): TItem | undefined {\n    return this.store.getByDOM(dom);\n  }\n\n  /** Get items filtered by predicate */\n  public getByFilter(predicate: (item: TItem) => boolean): TItem[] {\n    return this.store.filter(predicate);\n  }\n\n  /** Find item by predicate */\n  public getByFind(predicate: (item: TItem) => boolean): TItem | undefined {\n    return this.store.find(predicate);\n  }\n\n  /** Get count */\n  public get length(): number {\n    return this.store.length;\n  }\n\n  /**\n   * Get all active items\n   */\n  public getActive(): TItem[] {\n    return this.getByFilter((item) => item.active);\n  }\n\n  /** Get all items by parent ID */\n  public getAllByParentId(\n    parentId: string,\n    parentType: 'card' | 'set' | 'group' | 'field'\n  ): TItem[] {\n    return this.getByFilter((item) => {\n      if (!('parentHierarchy' in item)) return false;\n      switch (parentType) {\n        case 'card':\n          return 'cardId' in item.parentHierarchy && item.parentHierarchy.cardId === parentId;\n        case 'set':\n          return 'setId' in item.parentHierarchy && item.parentHierarchy.setId === parentId;\n        case 'group':\n          return 'groupId' in item.parentHierarchy && item.parentHierarchy.groupId === parentId;\n        case 'field':\n          return 'fieldId' in item.parentHierarchy && item.parentHierarchy.fieldId === parentId;\n        default:\n          return false;\n      }\n    });\n  }\n\n  /**\n   * Get the current item\n   */\n  public getCurrent(): TItem | undefined {\n    return this.getByFind((item) => item.current);\n  }\n\n  /**\n   * Get the current item index\n   */\n  public getCurrentIndex(): number {\n    const current = this.getCurrent();\n    if (!current) return -1;\n\n    return current.index;\n  }\n\n  /**\n   * Get the current item id\n   */\n  public getCurrentId(): string | undefined {\n    return this.getCurrent()?.id;\n  }\n\n  /** Check if first */\n  public isFirst(): boolean {\n    const currentIndex = this.getCurrentIndex();\n    return currentIndex === 0;\n  }\n\n  /** Check if last */\n  public isLast(): boolean {\n    const currentIndex = this.getCurrentIndex();\n    return currentIndex === this.length - 1;\n  }\n\n  /**\n   * Get navigation order\n   * @returns Array of item indexes in display order\n   */\n  public getNavigationOrder(): number[] {\n    return this.navigationOrder;\n  }\n\n  /**\n   * Get next position\n   * @returns Next position or undefined if on last position\n   */\n  public getNextPosition(): number | undefined {\n    const currentIndex = this.getCurrentIndex();\n    if (currentIndex === undefined) return undefined;\n\n    const currentPosition = this.navigationOrder.indexOf(currentIndex);\n\n    if (currentPosition >= this.navigationOrder.length - 1) {\n      return undefined;\n    }\n\n    return this.navigationOrder[currentPosition + 1];\n  }\n\n  /**\n   * Get previous position\n   * @returns Previous position or undefined if on first position\n   */\n  public getPrevPosition(): number | undefined {\n    const currentIndex = this.getCurrentIndex();\n    if (currentIndex === undefined) return undefined;\n\n    const currentPosition = this.navigationOrder.indexOf(currentIndex);\n\n    if (currentPosition <= 0) {\n      return undefined;\n    }\n\n    return this.navigationOrder[currentPosition - 1];\n  }\n\n  /**\n   * Write states to form\n   */\n  public setStates(): void {\n    const states = this.calculateStates();\n    this.form.setStates(states as StateForItem<TItem>);\n  }\n}\n", "/**\n * Card Manager\n *\n * Handles card discovery and access throughout the form lifecycle.\n * Cards are optional large UI sections (e.g., intro, form, success).\n */\n\nimport { ATTR } from '../constants';\nimport type { CardItem, CardParentHierarchy, FormCardState } from '../types';\nimport { extractTitle, parseElementAttribute } from '../utils';\nimport { ItemManager } from './item-manager';\n\n/**\n * CardManager Implementation\n *\n * Discovers and manages card elements in the form hierarchy.\n * Provides access to cards by index or ID.\n */\nexport class CardManager extends ItemManager<CardItem> {\n  protected readonly itemType = 'card';\n\n  /**\n   * Create data object\n   * Parses the element attribute and creates a CardItem object\n   *\n   * @param element - HTMLElement\n   * @param index - Index of the element within the list of cards\n   * @returns CardItem | undefined\n   */\n  protected createItemData(element: HTMLElement, index: number): CardItem | undefined {\n    if (!(element instanceof HTMLElement)) return;\n\n    const attrValue = element.getAttribute(`${ATTR}-element`);\n    if (!attrValue) return;\n\n    const parsed = parseElementAttribute(attrValue);\n\n    // Skip if not a card\n    if (parsed.type !== this.itemType) return;\n\n    // Extract title with priority resolution\n    const titleData = extractTitle(element, this.itemType, parsed.id, index);\n\n    // Check if the card has any sets\n    const hasSets = !!element.querySelector(`[${ATTR}-element^=\"set\"]`);\n\n    // Create card item object\n    return {\n      element,\n      index,\n      id: titleData.id,\n      visible: true,\n      active: index === 0,\n      type: this.itemType,\n      parentHierarchy: this.findParentHierarchy<CardParentHierarchy>(element),\n      visited: index === 0,\n      completed: !hasSets,\n      current: index === 0,\n      title: titleData.title,\n      progress: hasSets ? 0 : 100,\n      isIncluded: true,\n      isValid: !hasSets,\n    };\n  }\n\n  /**\n   * Calculate card-specific states\n   * Aggregates data from all cards and their child sets\n   *\n   * @returns FormCardState - Complete card state object\n   */\n  public calculateStates(): FormCardState {\n    const currentCard = this.getCurrent();\n    const currentCardIndex = currentCard ? currentCard.index : -1;\n    const currentCardId = currentCard ? currentCard.id : null;\n    const currentCardTitle = currentCard ? currentCard.title : null;\n    const previousCardIndex = currentCardIndex > 0 ? currentCardIndex - 1 : null;\n    const nextCardIndex = currentCardIndex < this.length - 1 ? currentCardIndex + 1 : null;\n    const completedCards = new Set(\n      this.getByFilter((item) => item.completed).map((item) => item.id)\n    );\n    const visitedCards = new Set(this.getByFilter((item) => item.visited).map((item) => item.id));\n    const totalCards = this.length;\n    const cardsComplete = completedCards.size;\n    const cardValidity = this.getAll().reduce(\n      (acc, item) => {\n        acc[item.id] = item.isValid;\n        return acc;\n      },\n      {} as Record<string, boolean>\n    );\n\n    return {\n      currentCardIndex,\n      currentCardId,\n      currentCardTitle,\n      activeCardIndices: this.getActiveIndices(),\n      previousCardIndex,\n      nextCardIndex,\n      completedCards,\n      visitedCards,\n      totalCards,\n      cardsComplete,\n      cardValidity,\n    };\n  }\n\n  protected buildItemData(item: CardItem): CardItem {\n    const sets = this.form.setManager.getAllByParentId(item.id, 'card');\n    const completed = sets.length > 0 ? sets.every((set) => set.completed) : true;\n    const isValid = sets.length > 0 ? sets.every((set) => set.isValid) : true;\n\n    const fieldsInCard = this.form.fieldManager\n      .getAllByParentId(item.id, 'card')\n      .filter((field) => field.isIncluded);\n\n    const progress =\n      (fieldsInCard.filter((field) => field.completed).length / fieldsInCard.length) * 100;\n\n    // Evaluate conditional visibility\n    const isIncluded = this.form.conditionManager.evaluateElementCondition(item.element);\n\n    return {\n      ...item,\n      completed,\n      isValid,\n      progress,\n      isIncluded,\n    };\n  }\n\n  /**\n   * Find the parent item for a card\n   *\n   * @param element - The card element\n   * @returns null (cards have no parent)\n   */\n  protected findParentItem(element: HTMLElement): undefined {\n    this.logWarn('findParentElement should not be called on CardManager', 'runtime', { element });\n    return undefined;\n  }\n}\n", "/**\n * Condition Manager\n *\n * Service for evaluating conditional visibility expressions.\n * Hierarchy managers call evaluateElementCondition() during buildItemData()\n * to determine isIncluded based on showif/hideif attributes.\n * Triggers rebuilds when field values change.\n */\n\nimport { ATTR } from '../constants/attr';\nimport type {\n  ComparisonOperator,\n  Condition,\n  ConditionalElement,\n  ConditionExpression,\n  InputChangedEvent,\n  LogicalOperator,\n} from '../types';\nimport { parseElementAttribute, plural } from '../utils';\nimport { BaseManager } from './base-manager';\n\n/**\n * ConditionManager Implementation\n *\n * Service-oriented manager that provides condition evaluation for hierarchy managers.\n * Managers call evaluateElementCondition() during buildItemData() to determine isIncluded.\n */\nexport class ConditionManager extends BaseManager {\n  /** All conditional elements indexed by element */\n  private conditionalElements: Map<HTMLElement, ConditionalElement> = new Map();\n\n  /** Dependency graph: field name -> Set of elements that depend on it */\n  private affectedElements: Map<string, Set<HTMLElement>> = new Map();\n\n  /**\n   * Initialize ConditionManager\n   */\n  public init(): void {\n    this.groupStart('Initializing Conditions');\n    this.discoverConditionalElements();\n    this.setupEventListeners();\n\n    this.logDebug('Initialized', {\n      conditionalElements: this.conditionalElements.size,\n      dependencies: Object.fromEntries(this.affectedElements),\n    });\n    this.groupEnd();\n  }\n\n  /**\n   * Cleanup manager resources\n   */\n  public destroy(): void {\n    this.conditionalElements.clear();\n    this.affectedElements.clear();\n    this.logDebug('ConditionManager destroyed');\n  }\n\n  // ============================================\n  // Discovery\n  // ============================================\n\n  /**\n   * Discover all conditional elements in the form\n   * Finds elements with [data-form-showif] or [data-form-hideif]\n   */\n  private discoverConditionalElements(): void {\n    const rootElement = this.form.getRootElement();\n    if (!rootElement) {\n      throw this.createError('Cannot discover conditional elements: root element is null', 'init', {\n        cause: rootElement,\n      });\n    }\n\n    // Query all conditional elements\n    const elements = this.form.queryAll<HTMLElement>(`[${ATTR}-showif], [${ATTR}-hideif]`);\n\n    this.conditionalElements.clear();\n    this.affectedElements.clear();\n\n    elements.forEach((element) => {\n      this.registerCondition(element);\n    });\n\n    this.logDebug(`Discovered ${this.conditionalElements.size} conditional elements`, {\n      elements: Array.from(this.conditionalElements.values()),\n      dependencyGraph: Object.fromEntries(this.affectedElements),\n    });\n  }\n\n  /**\n   * Register a conditional element\n   * Parses expressions and builds dependency graph\n   *\n   * @param element - HTMLElement with showif/hideif attributes\n   */\n  private registerCondition(element: HTMLElement): void {\n    const showIfAttr = element.getAttribute(`${ATTR}-showif`);\n    const hideIfAttr = element.getAttribute(`${ATTR}-hideif`);\n\n    if (!showIfAttr && !hideIfAttr) return;\n\n    const conditionalElement: ConditionalElement = {\n      element,\n      showIfExpression: showIfAttr ? this.parseExpression(showIfAttr) : undefined,\n      hideIfExpression: hideIfAttr ? this.parseExpression(hideIfAttr) : undefined,\n      dependsOn: new Set<string>(),\n    };\n\n    // Extract all field dependencies\n    if (conditionalElement.showIfExpression) {\n      conditionalElement.showIfExpression.conditions.forEach((condition) => {\n        conditionalElement.dependsOn.add(condition.field);\n        this.addToDependencyGraph(condition.field, element);\n      });\n    }\n\n    if (conditionalElement.hideIfExpression) {\n      conditionalElement.hideIfExpression.conditions.forEach((condition) => {\n        conditionalElement.dependsOn.add(condition.field);\n        this.addToDependencyGraph(condition.field, element);\n      });\n    }\n\n    this.conditionalElements.set(element, conditionalElement);\n  }\n\n  /**\n   * Add element to dependency graph\n   *\n   * @param fieldName - Field name that affects visibility\n   * @param element - Element that depends on the field\n   */\n  private addToDependencyGraph(fieldName: string, element: HTMLElement): void {\n    if (!this.affectedElements.has(fieldName)) {\n      this.affectedElements.set(fieldName, new Set());\n    }\n    this.affectedElements.get(fieldName)!.add(element);\n  }\n\n  // ============================================\n  // Expression Parsing\n  // ============================================\n\n  /**\n   * Parse condition expression\n   * Supports: {fieldName} operator value && {fieldName2} operator2 value2\n   *\n   * @param expression - Raw expression string\n   * @returns Parsed expression tree\n   */\n  private parseExpression(expression: string): ConditionExpression {\n    const conditions: Condition[] = [];\n    const logicalOperators: LogicalOperator[] = [];\n\n    // Split by logical operators while preserving them\n    const parts = expression.split(/(\\s*(?:&&|\\|\\|)\\s*)/);\n\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i].trim();\n\n      // Check if this part is a logical operator\n      if (part === '&&' || part === '||') {\n        logicalOperators.push(part);\n        continue;\n      }\n\n      // Parse condition\n      const condition = this.parseCondition(part);\n      if (condition) {\n        conditions.push(condition);\n      }\n    }\n\n    return { conditions, logicalOperators };\n  }\n\n  /**\n   * Parse single condition: {fieldName} operator value\n   *\n   * @param conditionStr - Single condition string\n   * @returns Parsed condition or undefined\n   */\n  private parseCondition(conditionStr: string): Condition | undefined {\n    // Extract field name from {}\n    const fieldMatch = conditionStr.match(/\\{([^}]+)\\}/);\n    if (!fieldMatch) {\n      this.logWarn(`Invalid condition syntax: ${conditionStr}`);\n      return undefined;\n    }\n\n    const field = fieldMatch[1].trim();\n\n    // Remove field part to parse operator and value\n    const remainder = conditionStr.substring(fieldMatch.index! + fieldMatch[0].length).trim();\n\n    // Match operator (support multi-character operators like >=, <=, *=, ^=, $=)\n    const operatorMatch = remainder.match(/^(>=|<=|\\*=|\\^=|\\$=|!=|=|>|<)/);\n    if (!operatorMatch) {\n      this.logWarn(`Invalid operator in condition: ${conditionStr}`);\n      return undefined;\n    }\n\n    const operator = operatorMatch[1] as ComparisonOperator;\n\n    // Extract value (everything after operator, trimmed)\n    const value = remainder.substring(operator.length).trim();\n\n    return { field, operator, value };\n  }\n\n  // ============================================\n  // Public Evaluation API\n  // ============================================\n\n  /**\n   * Evaluate condition for an element\n   * Called by hierarchy managers during buildItemData()\n   *\n   * @param element - Element to evaluate\n   * @returns Whether element should be included (visible)\n   */\n  public evaluateElementCondition(element: HTMLElement): boolean {\n    const conditionalElement = this.conditionalElements.get(element);\n\n    // If no conditions, element is always included\n    if (!conditionalElement) return true;\n\n    let showIfResult = true;\n    let hideIfResult = false;\n\n    // Evaluate showif expression\n    if (conditionalElement.showIfExpression) {\n      showIfResult = this.evaluateExpression(conditionalElement.showIfExpression);\n    }\n\n    // Evaluate hideif expression\n    if (conditionalElement.hideIfExpression) {\n      hideIfResult = this.evaluateExpression(conditionalElement.hideIfExpression);\n    }\n\n    // Element is included if showif is true AND hideif is false\n    return showIfResult && !hideIfResult;\n  }\n\n  /**\n   * Check if element has conditions\n   *\n   * @param element - Element to check\n   * @returns Whether element has showif/hideif attributes\n   */\n  public hasConditions(element: HTMLElement): boolean {\n    return this.conditionalElements.has(element);\n  }\n\n  // ============================================\n  // Expression Evaluation\n  // ============================================\n\n  /**\n   * Evaluate expression tree with logical operators\n   *\n   * @param expression - Parsed expression\n   * @returns Evaluation result\n   */\n  private evaluateExpression(expression: ConditionExpression): boolean {\n    const { conditions, logicalOperators } = expression;\n\n    if (conditions.length === 0) return true;\n    if (conditions.length === 1) {\n      return this.evaluateConditionPart(conditions[0]);\n    }\n\n    // Evaluate first condition\n    let result = this.evaluateConditionPart(conditions[0]);\n\n    // Apply logical operators\n    for (let i = 0; i < logicalOperators.length; i++) {\n      const operator = logicalOperators[i];\n      const nextCondition = conditions[i + 1];\n\n      if (!nextCondition) break;\n\n      const nextResult = this.evaluateConditionPart(nextCondition);\n\n      if (operator === '&&') {\n        result = result && nextResult;\n      } else if (operator === '||') {\n        result = result || nextResult;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Evaluate single condition part\n   *\n   * @param condition - Parsed condition\n   * @returns Evaluation result\n   */\n  private evaluateConditionPart(condition: Condition): boolean {\n    const { field, operator, value } = condition;\n\n    // Get current value from form data\n    const currentValue = this.getFieldValue(field);\n\n    // Convert to string for comparison\n    const currentValueStr = String(currentValue ?? '').toLowerCase();\n    const expectedValueStr = value.toLowerCase();\n\n    // Evaluate based on operator\n    switch (operator) {\n      case '=':\n        return currentValueStr === expectedValueStr;\n      case '!=':\n        return currentValueStr !== expectedValueStr;\n      case '>':\n        return parseFloat(currentValueStr) > parseFloat(expectedValueStr);\n      case '<':\n        return parseFloat(currentValueStr) < parseFloat(expectedValueStr);\n      case '>=':\n        return parseFloat(currentValueStr) >= parseFloat(expectedValueStr);\n      case '<=':\n        return parseFloat(currentValueStr) <= parseFloat(expectedValueStr);\n      case '*=': // Contains\n        return currentValueStr.includes(expectedValueStr);\n      case '^=': // Starts with\n        return currentValueStr.startsWith(expectedValueStr);\n      case '$=': // Ends with\n        return currentValueStr.endsWith(expectedValueStr);\n      default:\n        this.logWarn(`Unknown operator: ${operator}`);\n        return false;\n    }\n  }\n\n  /**\n   * Get field value from input manager or form state\n   *\n   * @param fieldName - Name of the field/input\n   * @returns Current value\n   */\n  private getFieldValue(fieldName: string): unknown {\n    // Try to get input by name (id)\n    const input = this.form.inputManager.getById(fieldName);\n    if (input) {\n      return input.value;\n    }\n\n    // If not found, check if it's a form state variable (form.*)\n    if (fieldName.startsWith('form.')) {\n      const stateKey = fieldName.substring(5);\n      const state = this.form.getAllState();\n      return state[stateKey as keyof typeof state];\n    }\n\n    this.logWarn(`Field not found: ${fieldName}`);\n    return undefined;\n  }\n\n  // ============================================\n  // Event Listeners\n  // ============================================\n\n  /**\n   * Setup event listeners\n   */\n  private setupEventListeners(): void {\n    // Listen to input changes\n    this.form.subscribe('form:input:changed', (payload) => {\n      this.onInputChange(payload);\n    });\n\n    this.logDebug('Event listeners setup');\n  }\n\n  /**\n   * Handle field value change\n   * Triggers rebuilds for affected hierarchy items\n   * Defers rebuild to next tick to ensure input values are fresh\n   *\n   * @param payload - Input change payload\n   */\n  private onInputChange(payload: InputChangedEvent): void {\n    const { name } = payload;\n\n    // Get all elements affected by this field\n    const affectedElements = this.affectedElements.get(name);\n    if (!affectedElements || affectedElements.size === 0) return;\n\n    this.logDebug(\n      `Rebuilding ${affectedElements.size} affected ${plural('element', affectedElements.size)}`\n    );\n\n    // Trigger rebuild for all hierarchy managers\n    // This will cause buildItemData() to be called, which will re-evaluate conditions\n    // The rebuild will update isIncluded flags for all affected items\n    this.form.cardManager.rebuildActive();\n    this.form.setManager.rebuildActive();\n    this.form.groupManager.rebuildActive();\n    this.form.fieldManager.rebuildActive();\n    this.form.inputManager.rebuildActive();\n    this.form.inputManager.applyStates();\n\n    // Emit event for each affected element so DisplayManager can update visibility\n    // This ensures immediate visibility changes without waiting for navigation\n    affectedElements.forEach((element) => {\n      const attrValue = element.getAttribute(`${ATTR}-element`);\n      if (!attrValue) return;\n      const parsed = parseElementAttribute(attrValue);\n      if (!parsed) return;\n\n      this.form.emit('form:condition:evaluated', {\n        element,\n        type: parsed.type as 'card' | 'set' | 'group' | 'field',\n      });\n    });\n  }\n\n  // ============================================\n  // Public API\n  // ============================================\n\n  /**\n   * Get all elements affected by a field\n   *\n   * @param fieldName - Field name\n   * @returns Set of affected elements\n   */\n  public getAffectedElements(fieldName: string): Set<HTMLElement> {\n    return this.affectedElements.get(fieldName) || new Set();\n  }\n}\n", "/**\n * Display Manager\n *\n * Handles showing/hiding form elements at all hierarchy levels (cards, sets, groups, fields).\n * Simple display toggling without animations (instant show/hide).\n * Behavior-aware: shows/hides appropriate level based on behavior mode.\n * Will be replaced/enhanced by AnimationManager in future phases.\n */\n\nimport { ATTR } from '../constants';\nimport type { ItemData, UpdatableItemData } from '../types';\nimport { BaseManager } from './base-manager';\nimport type { ItemManager } from './item-manager';\n\n/**\n * DisplayManager Implementation\n *\n * Subscribes to navigation change events and updates element visibility.\n * Uses display: none/block for instant showing/hiding.\n */\nexport class DisplayManager extends BaseManager {\n  // ============================================\n  // Lifecycle\n  // ============================================\n\n  /**\n   * Initialize the manager\n   */\n  public init(): void {\n    this.groupStart(`Initializing Display`);\n    this.setupEventListeners();\n    this.initializeDisplay();\n\n    this.logDebug('Initialized');\n    this.groupEnd();\n  }\n\n  /**\n   * Cleanup manager resources\n   */\n  public destroy(): void {\n    this.logDebug('DisplayManager destroyed');\n  }\n\n  // ============================================\n  // Event Listeners\n  // ============================================\n\n  /**\n   * Setup event listeners for navigation events based on behavior\n   */\n  private setupEventListeners(): void {\n    this.form.subscribe('form:navigation:changed', (payload) => {\n      this.updateDisplay(payload.target);\n    });\n\n    // Listen for condition evaluation events to immediately update visibility\n    // When a conditional element's visibility changes, we need to update the display\n    // without waiting for navigation state changes\n    this.form.subscribe('form:condition:evaluated', (payload) => {\n      let manager: ItemManager<ItemData> | undefined;\n      switch (payload.type) {\n        case 'card':\n          manager = this.form.cardManager;\n          break;\n        case 'set':\n          manager = this.form.setManager;\n          break;\n        case 'group':\n          manager = this.form.groupManager;\n          break;\n        case 'field':\n          manager = this.form.fieldManager;\n          break;\n        default:\n          return;\n      }\n\n      this.handleVisibility(manager);\n    });\n\n    this.logDebug('DisplayManager event listeners setup');\n  }\n\n  // ============================================\n  // Handle Navigation Changes\n  // ============================================\n\n  /**\n   * Initialize the display\n   */\n  private initializeDisplay(): void {\n    this.handleVisibility(this.form.cardManager);\n    this.handleVisibility(this.form.setManager);\n    this.handleVisibility(this.form.groupManager);\n    this.handleVisibility(this.form.fieldManager);\n    this.removeInitialStyles();\n  }\n\n  /**\n   * Remove initial styles from all elements\n   */\n  private removeInitialStyles(): void {\n    const elements = this.form.queryAll(`[${ATTR}-initialdisplay]`);\n    elements.forEach((element) => {\n      element.removeAttribute(`${ATTR}-initialdisplay`);\n    });\n  }\n\n  /**\n   * Update display depending on the state changed, no need for behavior\n   */\n  private updateDisplay(key: 'card' | 'set' | 'group' | 'field'): void {\n    switch (key) {\n      case 'card':\n        this.handleVisibility(this.form.cardManager);\n        break;\n      case 'set':\n        this.handleVisibility(this.form.setManager);\n        break;\n      case 'group':\n        this.handleVisibility(this.form.groupManager);\n        break;\n      case 'field':\n        this.handleVisibility(this.form.fieldManager);\n        break;\n      default:\n        return;\n    }\n  }\n\n  /**\n   * Handle item visibility based on data\n   */\n  private handleVisibility<TItem extends ItemData>(manager: ItemManager<TItem>): void {\n    const items = manager.getAll();\n    items.forEach((item) => {\n      this.showElement(item, (visible) =>\n        manager.updateItemData(item.index, { visible } as UpdatableItemData<TItem>)\n      );\n    });\n  }\n\n  /**\n   * Show/Hide an element\n   * Sets \"display: none\" or removes display property based on active state AND isIncluded\n   * Updates the \"active\" data-attribute to be inline with the display property\n   * Updates the visible flag to be inline with the active state\n   */\n  public showElement(item: ItemData, updateVisible: (visible: boolean) => void): void {\n    const { element, active, type, isIncluded } = item;\n\n    // Element should only be visible if active AND included\n    const shouldBeVisible = active && isIncluded;\n\n    if (shouldBeVisible) element.style.removeProperty('display');\n    else element.style.setProperty('display', 'none');\n\n    element.setAttribute(`${ATTR}-${type}-active`, active.toString());\n    element.setAttribute(`${ATTR}-${type}-included`, isIncluded.toString());\n\n    // Update visible flag\n    updateVisible(shouldBeVisible);\n  }\n}\n", "import { ATTR } from '../constants';\nimport type {\n  ErrorItem,\n  ErrorParentElement,\n  ErrorParentHierarchy,\n  ErrorTriggeredEvent,\n} from '../types';\nimport { HierarchyBuilder, ItemStore, parseElementAttribute } from '../utils';\nimport { BaseManager } from './base-manager';\n\nexport class ErrorManager extends BaseManager {\n  private store = new ItemStore<ErrorItem>();\n  protected readonly itemType = 'error';\n\n  /**\n   * Initialize the manager\n   */\n  public init(): void {\n    this.groupStart(`Initializing Error`);\n    this.discoverItems();\n    this.initializeErrors();\n    this.setupEventListeners();\n\n    this.logDebug('Initialized');\n    this.groupEnd();\n  }\n\n  /**\n   * Cleanup manager resources\n   */\n  public destroy(): void {\n    this.store.clear();\n    this.logDebug('ErrorManager destroyed');\n  }\n\n  private discoverItems(): void {\n    const rootElement = this.form.getRootElement();\n    if (!rootElement) {\n      throw this.form.createError('Cannot discover error items: root element is null', 'init', {\n        cause: rootElement,\n      });\n    }\n\n    // Query all buttons\n    const items = this.form.queryAll<HTMLElement>(`[${ATTR}-element=\"error\"]`);\n\n    this.store.clear();\n\n    items.forEach((item, index) => {\n      const itemData = this.createItemData(item, index);\n      if (!itemData) return;\n\n      this.store.add(itemData);\n    });\n\n    this.logDebug(`Discovered ${this.store.length} error items`, {\n      items: this.store.getAll(),\n    });\n  }\n\n  private createItemData(element: HTMLElement, index: number): ErrorItem | undefined {\n    if (!(element instanceof HTMLElement)) return;\n\n    const attrValue = element.getAttribute(`${ATTR}-element`);\n    if (!attrValue) return;\n\n    const parsed = parseElementAttribute(attrValue);\n    if (!parsed) return;\n\n    // Skip if not an error\n    if (parsed.type !== 'error') return;\n\n    return this.buildItemData({\n      element,\n      index,\n      id: parsed.id ?? `error-${index}`,\n      visible: false,\n      active: false,\n      type: parsed.type,\n      parentHierarchy: this.findParentHierarchy(element),\n    });\n  }\n\n  private buildItemData(item: ErrorItem): ErrorItem {\n    return {\n      ...item,\n    };\n  }\n\n  private findParentHierarchy(child: HTMLElement): ErrorParentHierarchy {\n    return HierarchyBuilder.findParentHierarchy<ErrorParentHierarchy>(child, this.form, (element) =>\n      this.findParentItem(element)\n    );\n  }\n\n  /**\n   * Find the parent item for an error\n   *\n   * @param element - The error element\n   * @returns Parent data or undefined\n   */\n  protected findParentItem(element: HTMLElement): ErrorParentElement | undefined {\n    const parentGroup = HierarchyBuilder.findParentByElement(element, 'group', () =>\n      this.form.groupManager.getAll()\n    );\n\n    const parentSet = HierarchyBuilder.findParentByElement(element, 'set', () =>\n      this.form.setManager.getAll()\n    );\n\n    const parentCard = HierarchyBuilder.findParentByElement(element, 'card', () =>\n      this.form.cardManager.getAll()\n    );\n\n    return parentGroup ?? parentSet ?? parentCard;\n  }\n\n  private initializeErrors(): void {\n    this.store.getAll().forEach((item) => {\n      item.element.style.setProperty('display', 'none');\n    });\n  }\n\n  private setupEventListeners(): void {\n    this.form.subscribe('form:error:triggered', (payload) => this.handleErrorTriggered(payload));\n    this.form.subscribe('form:error:cleared', () => this.handleErrorCleared());\n  }\n\n  private handleErrorTriggered(payload: ErrorTriggeredEvent): void {\n    this.store.getAll().forEach((item) => {\n      item.element.textContent = payload.message;\n      item.element.style.setProperty('display', 'flex');\n    });\n\n    if (payload.timeout) {\n      setTimeout(() => {\n        this.handleErrorCleared();\n      }, payload.timeout);\n    }\n  }\n\n  private handleErrorCleared(): void {\n    this.store.getAll().forEach((item) => {\n      item.element.style.removeProperty('display');\n    });\n  }\n}\n", "/**\n * Field Manager\n *\n * Handles field discovery and navigation order.\n */\n\nimport { ATTR } from '../constants/attr';\nimport type { FieldItem, FieldParentHierarchy, FormFieldState, GroupItem, SetItem } from '../types';\nimport { parseElementAttribute } from '../utils';\nimport { HierarchyBuilder } from '../utils/managers/hierarchy-builder';\nimport { ItemManager } from './item-manager';\n\n/**\n * FieldManager Implementation\n *\n * Discovers and manages field elements in the form hierarchy.\n * Builds navigation order.\n */\nexport class FieldManager extends ItemManager<FieldItem> {\n  protected readonly itemType = 'field';\n\n  /**\n   * Create data object\n   * Parses the element attribute and creates a FieldItem object\n   *\n   * @param element - HTMLElement\n   * @param index - Index of the element within the list of fields\n   * @returns FieldItem | undefined\n   */\n  protected createItemData(element: HTMLElement, index: number): FieldItem | undefined {\n    if (!(element instanceof HTMLElement)) return;\n\n    const attrValue = element.getAttribute(`${ATTR}-element`);\n    if (!attrValue) return;\n\n    const parsed = parseElementAttribute(attrValue);\n\n    // Skip if not a field\n    if (parsed.type !== this.itemType) return;\n\n    // Generate id (use parsed id if available, otherwise generate from index)\n    const id = parsed.id || `${this.itemType}-${index}`;\n\n    // Find parent hierarchy\n    const parent = this.findParentItem(element);\n    if (!parent) {\n      throw this.createError('Cannot discover fields: no parent element found', 'init', {\n        cause: { manager: 'FieldManager', element },\n      });\n    }\n\n    const parentHierarchy = this.findParentHierarchy<FieldParentHierarchy>(parent);\n    const active = this.determineActive(element, index);\n\n    // Create field item object\n    return {\n      element,\n      index,\n      id,\n      visible: true,\n      active,\n      type: this.itemType,\n      parentHierarchy,\n      current: active && index === 0,\n      visited: active,\n      completed: false,\n      isIncluded: true,\n      isValid: false,\n    };\n  }\n\n  /**\n   * Calculate field-specific states\n   * Aggregates data from all fields and their child groups and sets\n   *\n   * @returns FormFieldState - Complete field state object\n   */\n  public calculateStates(): FormFieldState {\n    const currentField = this.getCurrent();\n    const currentFieldIndex = currentField ? currentField.index : -1;\n    const currentFieldId = currentField ? currentField.id : null;\n    const previousFieldIndex = currentFieldIndex > 0 ? currentFieldIndex - 1 : null;\n    const nextFieldIndex = currentFieldIndex < this.length - 1 ? currentFieldIndex + 1 : null;\n    const completedFields = new Set(\n      this.getByFilter((item) => item.completed).map((item) => item.id)\n    );\n    const visitedFields = new Set(this.getByFilter((item) => item.visited).map((item) => item.id));\n    const totalFields = this.length;\n    const totalIncludedFields = this.getByFilter((item) => item.isIncluded).length;\n    const fieldsComplete = completedFields.size;\n    const fieldValidity = this.getAll().reduce(\n      (acc, item) => {\n        acc[item.id] = item.isValid;\n        return acc;\n      },\n      {} as Record<string, boolean>\n    );\n\n    return {\n      currentFieldIndex,\n      currentFieldId,\n      activeFieldIndices: this.getActiveIndices(),\n      previousFieldIndex,\n      nextFieldIndex,\n      completedFields,\n      visitedFields,\n      totalFields,\n      totalIncludedFields,\n      fieldsComplete,\n      fieldValidity,\n    };\n  }\n\n  protected buildItemData(item: FieldItem): FieldItem {\n    const input = this.form.inputManager.getByFind(\n      (input) => input.parentHierarchy.fieldId === item.id\n    );\n\n    if (!input) {\n      throw this.createError('Cannot merge field data: input not found', 'runtime', {\n        cause: { manager: 'FieldManager', element: item, input },\n      });\n    }\n\n    const { completed, isValid } = input;\n\n    // Evaluate conditional visibility\n    const isIncluded = this.form.conditionManager.evaluateElementCondition(item.element);\n\n    return {\n      ...item,\n      completed,\n      isValid,\n      isIncluded,\n    };\n  }\n\n  /**\n   * Find the parent item for a field\n   *\n   * @param element - The field element\n   * @returns Parent data or null\n   */\n  protected findParentItem(element: HTMLElement): GroupItem | SetItem | undefined {\n    const parentGroup = HierarchyBuilder.findParentByElement(element, 'group', () =>\n      this.form.groupManager.getAll()\n    );\n\n    const parentSet = HierarchyBuilder.findParentByElement(element, 'set', () =>\n      this.form.setManager.getAll()\n    );\n\n    return parentGroup ?? parentSet;\n  }\n}\n", "import { BaseManager } from './base-manager';\n\nexport class FocusManager extends BaseManager {\n  /** Initialize the manager */\n  public init(): void {\n    this.setupEventListeners();\n  }\n\n  /** Cleanup manager resources */\n  public destroy(): void {\n    // No cleanup needed currently\n  }\n\n  // ============================================\n  // Event Listeners\n  // ============================================\n\n  /**\n   * Setup event listeners for navigation events based on behavior\n   */\n  private setupEventListeners(): void {\n    this.form.subscribe('form:navigation:changed', () => {\n      this.handleNavigationChanged();\n    });\n\n    this.form.subscribe('form:navigation:denied', () => {\n      this.handleNavigationDenied();\n    });\n  }\n\n  // ============================================\n  // Focus Utilities\n  // ============================================\n\n  /**\n   * Check if element can receive focus\n   */\n  private isFocusable(element: HTMLElement): boolean {\n    return (\n      !element.hasAttribute('disabled') &&\n      element.offsetParent !== null && // Not hidden\n      element.tabIndex >= 0\n    );\n  }\n\n  /**\n   * Safely focus an element with error handling and scroll behavior\n   * @param element - Element to focus\n   * @param scrollIntoView - Whether to ensure element is visible (default: true)\n   * @returns true if focus succeeded, false otherwise\n   */\n  private focusElement(element: HTMLElement, scrollIntoView = true): boolean {\n    if (!this.isFocusable(element)) {\n      return false;\n    }\n\n    try {\n      element.focus();\n\n      if (scrollIntoView) {\n        element.scrollIntoView({\n          behavior: 'smooth',\n          block: 'center',\n          inline: 'nearest',\n        });\n      }\n\n      return true;\n    } catch (error) {\n      this.logError('Failed to focus element', error);\n      return false;\n    }\n  }\n\n  // ============================================\n  // Handle State Changes\n  // ============================================\n\n  /**\n   * Handle navigation changes and focus current field\n   */\n  private handleNavigationChanged = (): void => {\n    const currentFieldIndex = this.form.getState('currentFieldIndex');\n    if (currentFieldIndex < 0) return;\n\n    const currentInput = this.form.inputManager.getByIndex(currentFieldIndex);\n    if (!currentInput || !currentInput.active) return;\n\n    this.focusElement(currentInput.element);\n  };\n\n  /**\n   * Handle navigation denied\n   */\n  private handleNavigationDenied = (): void => {\n    const activeInputs = this.form.inputManager.getByFilter(\n      (input) => input.active && input.isIncluded\n    );\n\n    if (activeInputs.length === 0) return;\n\n    const firstInvalidInput = activeInputs.find((input) => !input.isValid);\n    if (!firstInvalidInput) return;\n\n    this.focusElement(firstInvalidInput.element);\n  };\n}\n", "/**\n * Group Manager\n *\n * Handles group discovery and access throughout the form lifecycle.\n * Groups are optional logical subgroups within sets (typically using <fieldset>).\n */\n\nimport { ATTR } from '../constants/attr';\nimport type { FormGroupState, GroupItem, GroupParentHierarchy, SetItem } from '../types';\nimport { extractTitle, parseElementAttribute } from '../utils';\nimport { HierarchyBuilder } from '../utils/managers/hierarchy-builder';\nimport { ItemManager } from './item-manager';\n\n/**\n * GroupManager Implementation\n *\n * Discovers and manages group elements in the form hierarchy.\n * Provides access to groups by index or ID.\n * Associates groups with their parent sets and cards.\n */\nexport class GroupManager extends ItemManager<GroupItem> {\n  protected readonly itemType = 'group';\n\n  /**\n   * Create data object\n   * Parses the element attribute and creates a GroupItem object\n   *\n   * @param element - HTMLElement\n   * @param index - Index of the element within the list of groups\n   * @returns GroupItem | undefined\n   */\n  protected createItemData(element: HTMLElement, index: number): GroupItem | undefined {\n    if (!(element instanceof HTMLElement)) return;\n\n    const attrValue = element.getAttribute(`${ATTR}-element`);\n    if (!attrValue) return;\n\n    const parsed = parseElementAttribute(attrValue);\n\n    // Skip if not a group\n    if (parsed.type !== this.itemType) return;\n\n    // Extract title with priority resolution\n    const titleData = extractTitle(element, this.itemType, parsed.id, index);\n\n    // Find parent hierarchy\n    const parentHierarchy = this.findParentHierarchy<GroupParentHierarchy>(element);\n    const active = this.determineActive(element, index);\n\n    // Create group item object\n    return {\n      element,\n      index,\n      id: titleData.id,\n      visible: true,\n      active,\n      type: this.itemType,\n      parentHierarchy,\n      current: active && index === 0,\n      visited: active,\n      completed: false,\n      title: titleData.title,\n      progress: 0,\n      isIncluded: true,\n      isValid: false,\n    };\n  }\n\n  /**\n   * Calculate group-specific states\n   * Aggregates data from all groups and their child fields\n   *\n   * @returns FormGroupState - Complete group state object\n   */\n  public calculateStates(): FormGroupState {\n    const currentGroup = this.getCurrent();\n    const currentGroupIndex = currentGroup ? currentGroup.index : -1;\n    const currentGroupId = currentGroup ? currentGroup.id : null;\n    const currentGroupTitle = currentGroup ? currentGroup.title : null;\n    const previousGroupIndex = currentGroupIndex > 0 ? currentGroupIndex - 1 : null;\n    const nextGroupIndex = currentGroupIndex < this.length - 1 ? currentGroupIndex + 1 : null;\n    const completedGroups = new Set(\n      this.getByFilter((item) => item.completed).map((item) => item.id)\n    );\n    const visitedGroups = new Set(this.getByFilter((item) => item.visited).map((item) => item.id));\n    const totalGroups = this.length;\n    const groupsComplete = completedGroups.size;\n    const groupValidity = this.getAll().reduce(\n      (acc, item) => {\n        acc[item.id] = item.isValid;\n        return acc;\n      },\n      {} as Record<string, boolean>\n    );\n\n    return {\n      currentGroupIndex,\n      currentGroupId,\n      currentGroupTitle,\n      activeGroupIndices: this.getActiveIndices(),\n      previousGroupIndex,\n      nextGroupIndex,\n      completedGroups,\n      visitedGroups,\n      totalGroups,\n      groupsComplete,\n      groupValidity,\n    };\n  }\n\n  protected buildItemData(item: GroupItem): GroupItem {\n    const includedFields = this.form.fieldManager\n      .getAllByParentId(item.id, 'group')\n      .filter((field) => field.isIncluded);\n\n    const completed = includedFields.every((field) => field.completed);\n    const isValid = includedFields.every((field) => field.isValid);\n    const progress =\n      (includedFields.filter((field) => field.completed).length / includedFields.length) * 100;\n\n    // Evaluate conditional visibility\n    const isIncluded = this.form.conditionManager.evaluateElementCondition(item.element);\n\n    return {\n      ...item,\n      completed,\n      isValid,\n      progress,\n      isIncluded,\n    };\n  }\n\n  /**\n   * Find the parent item for a group\n   *\n   * @param element - The group element\n   * @returns Parent data or null\n   */\n  protected findParentItem(element: HTMLElement): SetItem | undefined {\n    return HierarchyBuilder.findParentByElement(element, 'set', () =>\n      this.form.setManager.getAll()\n    );\n  }\n}\n", "/**\n * Input Manager\n *\n * Handles input discovery, event binding, and value extraction.\n * Groups radio/checkbox inputs by name attribute.\n * Only binds events to the current field's input for optimal performance.\n */\n\nimport { ATTR } from '../constants';\nimport type {\n  FieldItem,\n  FormInputState,\n  InputElement,\n  InputItem,\n  InputParentHierarchy,\n  UpdatableItemData,\n} from '../types';\nimport { HierarchyBuilder } from '../utils/managers/hierarchy-builder';\nimport { ItemManager } from './item-manager';\n\n/**\n * InputManager Implementation\n *\n * Discovers inputs within field wrappers and groups them by name.\n * Implements lazy event binding - only the active field inputs are bound to events.\n */\nexport class InputManager extends ItemManager<InputItem> {\n  protected readonly itemType = 'input';\n\n  /** Active event listeners for cleanup */\n  private activeListeners: Array<{\n    element: InputElement;\n    index: number;\n    name: string;\n    event: string;\n    handler: EventListener;\n  }> = [];\n\n  /**\n   * Initialize InputManager\n   */\n  public init(): void {\n    super.init(false);\n    this.setupEventListeners();\n    this.onInitialized();\n  }\n\n  /**\n   * Destroy InputManager\n   */\n  public destroy(): void {\n    this.unbindAllInputs();\n    super.destroy();\n  }\n\n  /**\n   * Discover all inputs in the form\n   * Queries within each field wrapper and groups by name attribute\n   */\n  protected discoverItems(): void {\n    const fields = this.form.fieldManager.getAll();\n\n    this.clear();\n\n    // Track which names we've already processed to avoid duplicates\n    const processedNames = new Set<string>();\n\n    fields.forEach((field, index) => {\n      // Query for inputs within this field wrapper\n      const inputs = Array.from(\n        field.element.querySelectorAll<InputElement>('input, select, textarea')\n      );\n\n      if (inputs.length === 0) {\n        this.form.logWarn(`Field \"${field.id}\" has no inputs`, { field });\n        return;\n      }\n\n      const parentHierarchy = this.findParentHierarchy<InputParentHierarchy>(field);\n\n      // Process each input found\n      inputs.forEach((input) => {\n        const data = this.createInputData(input, index, {\n          field,\n          processedNames,\n          parentHierarchy,\n          isGroup: inputs.length > 1,\n        });\n\n        if (!data) return;\n        this.update(data);\n      });\n    });\n\n    this.logDebug(`Discovered ${this.length} ${this.itemType}s`, {\n      elements: this.getAll(),\n    });\n  }\n\n  /**\n   * Not used - use createInputData instead\n   */\n  protected createItemData(): undefined {\n    return undefined;\n  }\n\n  /**\n   * Create input item data with additional context\n   * Private helper used by discoverElements() to handle input-specific logic\n   *\n   * @param input - InputElement (input/select/textarea)\n   * @param index - Index of the input within field\n   * @param props - Additional context for input discovery\n   * @returns InputItem | undefined\n   */\n  private createInputData(\n    input: InputElement,\n    index: number,\n    props: {\n      field: FieldItem;\n      processedNames: Set<string>;\n      parentHierarchy: InputParentHierarchy;\n      isGroup: boolean;\n    }\n  ): InputItem | undefined {\n    const { field, processedNames, parentHierarchy, isGroup } = props;\n\n    const name = input.getAttribute('name');\n    if (!name) {\n      throw this.createError('Cannot discover inputs: Input missing name attribute', 'init', {\n        cause: {\n          input,\n          field: parentHierarchy.fieldId,\n          group: parentHierarchy.groupId,\n          set: parentHierarchy.setId,\n          card: parentHierarchy.cardId,\n          form: parentHierarchy.formId,\n        },\n      });\n    }\n\n    // If we've already processed this name, it's part of a radio/checkbox group\n    if (processedNames.has(name)) {\n      // Find the existing item, add this input and recalc the data\n      const existingInput = this.getById(name);\n      if (existingInput) {\n        existingInput.inputs.push(input);\n        existingInput.isGroup = existingInput.inputs.length > 1;\n        this.mergeItemData(existingInput, {});\n      }\n      return;\n    }\n\n    // New input - create InputItem\n    processedNames.add(name);\n\n    const inputType = this.getInputType(input);\n\n    const isRequired = this.checkIfRequired(input);\n    const isValid = this.checkIfValid(input);\n    const { visited, active, current, isIncluded } = field;\n\n    // Check for format attribute\n    const format = input.getAttribute(`${ATTR}-format`) || undefined;\n\n    // Initialize formatConfig if format exists and input is text-based\n    let formatConfig: InputItem['formatConfig'];\n    if (format && (input instanceof HTMLInputElement || input instanceof HTMLTextAreaElement)) {\n      const { formattedLength, rawLength } = this.calculateFormatLengths(format);\n      const originalMaxLength = input.maxLength > -1 ? input.maxLength : null;\n\n      // IMPORTANT: Set maxLength BEFORE minLength to avoid constraint violation\n      // (cannot set minLength > current maxLength)\n\n      // Adjust maxLength based on original constraint\n      if (originalMaxLength !== null && originalMaxLength < formattedLength) {\n        // Case 1: Original maxLength is too short for format - extend it to allow format\n        input.maxLength = formattedLength;\n      } else if (originalMaxLength !== null && originalMaxLength > rawLength) {\n        // Case 2: Original maxLength allows more than raw length\n        // Allow typing beyond formatted length to reach originalMaxLength\n        // Formula: originalMaxLength - rawLength + formattedLength\n        // Example: 15 - 10 + 14 = 19 (allows typing past format to trigger removal)\n        input.maxLength = originalMaxLength - rawLength + formattedLength;\n      } else {\n        // Case 3: No maxLength or originalMaxLength <= rawLength\n        // Set to formatted length\n        input.maxLength = formattedLength;\n      }\n\n      // Set initial minLength to formatted length (after maxLength is set)\n      input.minLength = formattedLength;\n\n      formatConfig = {\n        pattern: format,\n        formattedLength,\n        rawLength,\n        originalMaxLength,\n      };\n    }\n\n    return {\n      element: input,\n      index,\n      id: name,\n      visible: true,\n      active,\n      type: 'input',\n      parentHierarchy,\n      current,\n      visited,\n      completed: isValid,\n      inputs: [input],\n      inputType,\n      value: this.getInputValue(input),\n      name,\n      isGroup,\n      isRequiredOriginal: isRequired,\n      isRequired,\n      isValid,\n      isIncluded,\n      format,\n      formatConfig,\n    };\n  }\n\n  /**\n   * Calculate input-specific states\n   * Returns formData object with all input values\n   *\n   * @returns FormInputState - Complete input state object\n   */\n  public calculateStates(): FormInputState {\n    return {\n      formData: this.getFormData(),\n    };\n  }\n\n  protected buildItemData(item: InputItem): InputItem {\n    // Get parent field to check if it's included\n    const parentField = this.form.fieldManager.getById(item.parentHierarchy.fieldId);\n    const isIncluded = parentField ? parentField.isIncluded : true;\n\n    // Input is only required if parent field is included AND input was originally required\n    const isRequired = isIncluded ? item.isRequiredOriginal : false;\n\n    // Set required state if it has changed\n    if (isRequired !== item.isRequired) {\n      this.setInputRequired(item, isRequired);\n    }\n\n    // Check if input is valid\n    const isValid = this.checkIfValid(item.element);\n\n    return {\n      ...item,\n      completed: isValid,\n      value: this.getValue(item.name),\n      isIncluded,\n      isRequired,\n      isValid,\n    };\n  }\n\n  public applyStates(): void {\n    this.getAll().forEach((item) => {\n      item.inputs.forEach((input) => {\n        input.required = item.isRequired;\n      });\n    });\n  }\n\n  /**\n   * Setup event listeners for state changes\n   */\n  private setupEventListeners(): void {\n    this.bindActiveInputs();\n    this.form.subscribe('form:navigation:changed', (payload) => {\n      if (payload.target === 'field') {\n        this.handleActiveFieldsChanged();\n      }\n    });\n  }\n\n  private handleActiveFieldsChanged(): void {\n    this.bindActiveInputs();\n    this.unbindInactiveInputs();\n  }\n\n  /**\n   * Bind events to the current field's input\n   * Automatically determines the correct event type based on input type\n   */\n  public bindActiveInputs(): void {\n    const activeItems = this.getActive();\n    if (activeItems.length === 0) return;\n\n    activeItems.forEach((item) => {\n      // If already bound, skip - check if any of this item's inputs are already bound\n      const alreadyBound = item.inputs.some((input) =>\n        this.activeListeners.some((listener) => listener.element === input)\n      );\n      if (alreadyBound) return;\n\n      // Determine event type for value changes\n      const eventType = this.getEventTypeForInput(item.element);\n\n      // Bind events to ALL inputs in the item (for radio/checkbox groups)\n      item.inputs.forEach((input) => {\n        // Check if this input needs formatting\n        const needsFormatting =\n          item.format &&\n          (input instanceof HTMLInputElement || input instanceof HTMLTextAreaElement);\n\n        const handler: EventListener = () => {\n          // Apply formatting FIRST if pattern exists\n          // This ensures the value is formatted before extraction and validation\n          if (needsFormatting) {\n            this.handleFormatting(\n              input as HTMLInputElement | HTMLTextAreaElement,\n              item.format!,\n              item\n            );\n          }\n\n          // Then extract and handle the change\n          const value = this.extractInputValue(item);\n          this.handleInputChange(item.name, value);\n        };\n\n        input.addEventListener(eventType, handler);\n        this.activeListeners.push({\n          element: input,\n          index: item.index,\n          name: item.name,\n          event: eventType,\n          handler,\n        });\n      });\n\n      this.logDebug(`Bound \"${eventType}\" events to input \"${item.name}\"`);\n    });\n  }\n\n  /**\n   * Unbind events from inputs not associated with active field indices\n   * @param activeIndices - Array of active field indices to keep bound\n   */\n  public unbindInactiveInputs(): void {\n    const activeItems = this.getActive();\n    if (activeItems.length === 0) return;\n\n    this.activeListeners = this.activeListeners.filter((listener) => {\n      const shouldRemove = !activeItems.find((item) => item.index === listener.index);\n\n      if (shouldRemove) {\n        listener.element.removeEventListener(listener.event, listener.handler);\n        this.logDebug(`Unbound \"${listener.event}\" events from input \"${listener.name}\"`);\n      }\n\n      return !shouldRemove; // Keep listeners that should NOT be removed\n    });\n  }\n\n  /**\n   * Unbind all active input listeners\n   * @internal Used during cleanup\n   */\n  private unbindAllInputs(): void {\n    this.activeListeners.forEach((listener) => {\n      listener.element.removeEventListener(listener.event, listener.handler);\n    });\n    this.activeListeners = [];\n  }\n\n  // ============================================\n  // Event Type Selection\n  // ============================================\n\n  /**\n   * Determine the correct event type for an input\n   * @param input - Input element to check\n   * @returns Event type to bind to\n   */\n  private getEventTypeForInput(input: InputElement): 'blur' | 'change' | 'input' {\n    // Handle select and textarea elements\n    if (input instanceof HTMLSelectElement) return 'change';\n    if (input instanceof HTMLTextAreaElement) return 'input';\n\n    // Handle input elements by type\n    const type = input.type.toLowerCase();\n\n    // Selection inputs use change\n    if (['radio', 'checkbox'].includes(type)) return 'change';\n\n    // Numeric and text-based inputs use input for real-time feedback\n    return 'input';\n  }\n\n  // ============================================\n  // Value Extraction\n  // ============================================\n\n  /**\n   * Extract value from an input item\n   * Handles all input types including radio/checkbox groups\n   * @param item - InputItem to extract value from\n   * @returns Extracted value (string, boolean, or array)\n   */\n  private extractInputValue(item: InputItem): unknown {\n    const { element } = item;\n\n    // Handle select elements\n    if (element instanceof HTMLSelectElement) {\n      return element.value;\n    }\n\n    // Handle textarea elements\n    if (element instanceof HTMLTextAreaElement) {\n      // Strip formatting if format pattern exists\n      if (item.format) {\n        return this.stripFormatting(element.value);\n      }\n      return element.value;\n    }\n\n    // Handle inputs by type\n    const type = item.inputType;\n\n    // Checkbox\n    if (type === 'checkbox') {\n      if (item.isGroup) {\n        // Checkbox group - return array of checked values\n\n        // Return a comma-separated string of checked values\n        return (item.inputs as HTMLInputElement[])\n          .filter((cb) => cb.checked)\n          .map((cb) => cb.value)\n          .join(', ');\n      }\n\n      // Single checkbox - return boolean\n      return element.checked;\n    }\n\n    // Radio - return selected value from group\n    if (type === 'radio') {\n      const checked = (item.inputs as HTMLInputElement[]).find((r) => r.checked);\n      return checked ? checked.value : null;\n    }\n\n    return element.value;\n  }\n\n  /**\n   * Get input value\n   * @param selector - ID or Index\n   * @returns Current value or undefined\n   */\n  private getValue(selector: string | number): unknown {\n    const item = this.getBySelector(selector);\n    if (!item) return undefined;\n\n    return item.value;\n  }\n\n  private getInputValue(input: InputElement): unknown {\n    if (input instanceof HTMLSelectElement || input instanceof HTMLTextAreaElement) {\n      return input.value;\n    }\n\n    // Handle HTMLInputElements by type\n    const type = input.type.toLowerCase();\n\n    // Checkbox or radio\n    if (type === 'checkbox' || type === 'radio') {\n      return input.checked;\n    }\n\n    // Default - return value as string\n    return input.value;\n  }\n\n  // ============================================\n  // Value Setting\n  // ============================================\n\n  /**\n   * Set input value\n   * @param name - Input name attribute\n   * @param value - Value to set\n   */\n  public setValue(selector: number | string, value: unknown): void {\n    const item = this.getBySelector(selector);\n    if (!item) {\n      this.form.logWarn(`Cannot set value for input \"${selector}\" - not found`);\n      return;\n    }\n\n    const { element } = item;\n\n    // Handle select and textarea elements\n    if (element instanceof HTMLSelectElement || element instanceof HTMLTextAreaElement) {\n      element.value = String(value);\n      return;\n    }\n\n    // Handle input elements by type\n    const type = item.inputType;\n\n    // Checkbox\n    if (type === 'checkbox') {\n      if (Array.isArray(value)) {\n        // Checkbox group - check all inputs with matching values\n        (item.inputs as HTMLInputElement[]).forEach((cb) => {\n          cb.checked = value.includes(cb.value);\n        });\n      } else {\n        // Single checkbox - treat as boolean\n        (element as HTMLInputElement).checked = Boolean(value);\n      }\n      return;\n    }\n\n    // Radio - check the radio with matching value\n    if (type === 'radio') {\n      (item.inputs as HTMLInputElement[]).forEach((r) => {\n        r.checked = r.value === String(value);\n      });\n      return;\n    }\n\n    // Default - set value as string\n    element.value = String(value);\n  }\n\n  // ============================================\n  // Form Data\n  // ============================================\n\n  /**\n   * Get form data as key-value pairs\n   * @returns Object with input names and values\n   */\n  public getFormData(): Record<string, unknown> {\n    const formData: Record<string, unknown> = {};\n\n    this.getByFilter((item) => item.isIncluded).forEach((item) => {\n      formData[item.name] = this.extractInputValue(item);\n    });\n\n    return formData;\n  }\n\n  // ============================================\n  // Input Formatting\n  // ============================================\n\n  /**\n   * Calculate format lengths from pattern string\n   * @param pattern - Format pattern (e.g., \"(xxx) xxx-xxxx\")\n   * @returns Object with formattedLength and rawLength\n   */\n  private calculateFormatLengths(pattern: string): { formattedLength: number; rawLength: number } {\n    const rawLength = (pattern.match(/[Xx]/g) || []).length;\n    const formattedLength = pattern.length;\n    return { formattedLength, rawLength };\n  }\n\n  /**\n   * Update minLength and maxLength attributes based on current raw value length\n   * Dynamically adjusts constraints when user exceeds or returns within format capacity\n   *\n   * IMPORTANT: Attribute order matters to avoid browser constraint violations:\n   * - When increasing (raw \u2192 formatted): Set maxLength first, then minLength\n   * - When decreasing (formatted \u2192 raw): Set minLength first, then maxLength\n   *\n   * @param input - Input element to update\n   * @param item - InputItem containing formatConfig\n   * @param rawLength - Current length of raw (digits only) value\n   */\n  private updateLengthConstraints(\n    input: HTMLInputElement | HTMLTextAreaElement,\n    item: InputItem,\n    rawLength: number\n  ): void {\n    if (!item.formatConfig) return;\n\n    const { formattedLength, rawLength: maxRawLength, originalMaxLength } = item.formatConfig;\n\n    // Determine if we're within format capacity\n    const withinFormatCapacity = rawLength <= maxRawLength;\n\n    if (withinFormatCapacity) {\n      // Within capacity - use formatted constraints\n      // Set maxLength FIRST to avoid minLength > maxLength error\n\n      // Determine correct maxLength for format mode\n      let targetMaxLength: number;\n      if (originalMaxLength !== null && originalMaxLength > maxRawLength) {\n        // Allow typing beyond formatted length to reach originalMaxLength\n        // Formula: originalMaxLength - rawLength + formattedLength\n        targetMaxLength = originalMaxLength - maxRawLength + formattedLength;\n      } else {\n        // Standard case: maxLength = formatted length\n        targetMaxLength = formattedLength;\n      }\n\n      if (input.maxLength !== targetMaxLength) {\n        input.maxLength = targetMaxLength;\n      }\n      if (input.minLength !== formattedLength) {\n        input.minLength = formattedLength;\n      }\n    } else {\n      // Exceeds capacity - use raw constraints\n      // Set minLength FIRST to avoid minLength > maxLength error\n      if (input.minLength !== maxRawLength) {\n        input.minLength = maxRawLength;\n      }\n      // Restore original maxLength or remove constraint\n      const newMaxLength = originalMaxLength !== null ? originalMaxLength : -1;\n      if (input.maxLength !== newMaxLength) {\n        input.maxLength = newMaxLength;\n      }\n    }\n  }\n\n  /**\n   * Apply format pattern to input value\n   * Formats the value according to pattern (e.g., \"(XXX) XXX-XXXX\")\n   * Maintains cursor position after formatting\n   * Updates minLength and maxLength constraints dynamically\n   *\n   * @param input - Input element to format\n   * @param pattern - Format pattern (X = digit placeholder)\n   * @param item - InputItem containing formatConfig\n   */\n  private handleFormatting(\n    input: HTMLInputElement | HTMLTextAreaElement,\n    pattern: string,\n    item: InputItem\n  ): void {\n    const cursorPosition = input.selectionStart || 0;\n    const oldValue = input.value;\n    const rawValue = this.stripFormatting(oldValue);\n\n    // Update length constraints based on current raw value length\n    this.updateLengthConstraints(input, item, rawValue.length);\n\n    // Apply formatting\n    const formattedValue = this.applyFormat(rawValue, pattern);\n\n    // Only update if value changed\n    if (formattedValue !== oldValue) {\n      input.value = formattedValue;\n\n      // Calculate new cursor position\n      const newCursorPosition = this.calculateCursorPosition(\n        oldValue,\n        formattedValue,\n        cursorPosition\n      );\n\n      // Restore cursor position\n      input.setSelectionRange(newCursorPosition, newCursorPosition);\n    }\n  }\n\n  /**\n   * Strip all non-digit characters from value\n   * @param value - Value to strip\n   * @returns Raw digits only\n   */\n  private stripFormatting(value: string): string {\n    return value.replace(/\\D/g, '');\n  }\n\n  /**\n   * Apply format pattern to raw digits\n   * If value exceeds pattern length, returns unformatted digits\n   * @param rawValue - Raw digit string\n   * @param pattern - Format pattern (X = digit)\n   * @returns Formatted value or raw digits if overflow\n   */\n  private applyFormat(rawValue: string, pattern: string): string {\n    // Count how many digit placeholders are in the pattern\n    const maxDigits = (pattern.match(/[Xx]/g) || []).length;\n\n    // If raw value exceeds pattern capacity, return raw digits (no formatting)\n    if (rawValue.length > maxDigits) {\n      return rawValue;\n    }\n\n    let formatted = '';\n    let rawIndex = 0;\n\n    for (let i = 0; i < pattern.length && rawIndex < rawValue.length; i++) {\n      const patternChar = pattern[i];\n\n      if (patternChar === 'X' || patternChar === 'x') {\n        // Insert digit\n        formatted += rawValue[rawIndex];\n        rawIndex += 1;\n      } else {\n        // Insert literal character\n        formatted += patternChar;\n      }\n    }\n\n    return formatted;\n  }\n\n  /**\n   * Calculate new cursor position after formatting\n   * Accounts for added/removed formatting characters\n   *\n   * @param oldValue - Value before formatting\n   * @param newValue - Value after formatting\n   * @param oldCursor - Cursor position before formatting\n   * @param pattern - Format pattern\n   * @returns New cursor position\n   */\n  private calculateCursorPosition(oldValue: string, newValue: string, oldCursor: number): number {\n    // Count how many digits are before cursor in old value\n    const digitsBeforeCursor = oldValue.slice(0, oldCursor).replace(/\\D/g, '').length;\n\n    // Find position in new value where we've seen that many digits\n    let digitCount = 0;\n    let newCursor = 0;\n\n    for (let i = 0; i < newValue.length; i++) {\n      if (/\\d/.test(newValue[i])) {\n        digitCount += 1;\n        if (digitCount === digitsBeforeCursor) {\n          newCursor = i + 1;\n          break;\n        }\n      }\n    }\n\n    // If we didn't find enough digits, put cursor at end\n    if (digitCount < digitsBeforeCursor) {\n      newCursor = newValue.length;\n    }\n\n    return newCursor;\n  }\n\n  // ============================================\n  // Input Change Handling\n  // ============================================\n\n  /**\n   * Handle input value change\n   * Updates formData state and emits event for ConditionManager\n   * @param name - Input name\n   * @param value - New value\n   * @internal Called by event handlers\n   */\n  private handleInputChange(name: string, value: unknown): void {\n    this.logDebug(`Input \"${name}\" changed to \"${value}\"`);\n\n    this.updateItemData(name, { value } as UpdatableItemData<InputItem>);\n    const formData = this.form.getState('formData');\n    this.form.setState('formData', { ...formData, [name]: value });\n    this.form.emit('form:input:changed', { name, value });\n    this.logDebug('Form data updated', { formData: this.form.getState('formData') });\n  }\n\n  /**\n   * Set required state for an input\n   * Updates both the InputItem and DOM attributes\n   *\n   * @param item - InputItem to update\n   * @param isRequired - New required state\n   * @internal\n   */\n  private setInputRequired(item: InputItem, isRequired: boolean): void {\n    item.isRequired = isRequired;\n\n    // Update DOM required attribute on all elements\n    item.inputs.forEach((input) => {\n      input.required = isRequired;\n    });\n  }\n\n  // ============================================\n  // Private Helpers\n  // ============================================\n\n  /**\n   * Find the parent field item for a field\n   *\n   * @param element - The input element\n   * @returns Parent field item\n   */\n  protected findParentItem(element: HTMLElement): FieldItem {\n    const parentField = HierarchyBuilder.findParentByElement(element, 'field', () =>\n      this.form.fieldManager.getAll()\n    );\n\n    if (!parentField) {\n      throw this.createError('Cannot discover inputs: no parent field found', 'init', {\n        cause: { manager: 'InputManager', element },\n      });\n    }\n\n    return parentField;\n  }\n\n  /**\n   * Get the input type from an element\n   */\n  private getInputType(element: InputElement): string {\n    if (element instanceof HTMLSelectElement) {\n      return 'select';\n    }\n\n    if (element instanceof HTMLTextAreaElement) {\n      return 'textarea';\n    }\n\n    return element.type.toLowerCase();\n  }\n\n  /**\n   * Check if an input is required\n   */\n  private checkIfRequired(element: InputElement): boolean {\n    return element.required;\n  }\n\n  /**\n   * Check if an input is valid\n   */\n  private checkIfValid(element: InputElement): boolean {\n    if (element instanceof HTMLInputElement) {\n      const { minLength, maxLength, value } = element;\n      if (\n        (minLength > -1 && value.length < minLength) ||\n        (maxLength > -1 && value.length > maxLength)\n      ) {\n        return false;\n      }\n    }\n    return element.checkValidity();\n  }\n}\n", "/**\n * Navigation Manager\n *\n * Handles navigation buttons (prev/next/submit) states based on Form State.\n * coordinates with managers to progress through the form.\n */\n\nimport type { CardItem, FieldItem, GroupItem, SetItem } from '../types';\nimport { BaseManager } from './base-manager';\n\n/**\n * NavigationManager Implementation\n *\n * Discovers navigation buttons and emits navigation:next/prev events.\n * Listens for boundary events to update button states.\n */\nexport class NavigationManager extends BaseManager {\n  private navigationEnabled: boolean = true;\n  private enterKeyHandler: ((e: KeyboardEvent) => void) | null = null;\n\n  /**\n   * Initialize the manager\n   */\n  public init(): void {\n    this.groupStart(`Initializing Navigation`);\n    this.setupEventListeners();\n\n    this.form.logDebug('Initialized');\n    this.groupEnd();\n  }\n\n  /**\n   * Cleanup manager resources\n   */\n  public destroy(): void {\n    this.removeEventListeners();\n\n    this.form.logDebug('NavigationManager destroyed');\n  }\n\n  // ============================================\n  // Event Listeners\n  // ============================================\n\n  /**\n   * Setup event listeners for button clicks and boundary events\n   */\n  private setupEventListeners(): void {\n    this.form.subscribe('form:navigation:request', (payload) => {\n      this.handleMove(payload.type);\n    });\n\n    this.setupEnterKeyListener();\n\n    this.form.logDebug('Event listeners setup');\n  }\n\n  /**\n   * Remove event listeners\n   */\n  private removeEventListeners(): void {\n    if (this.enterKeyHandler) {\n      document.removeEventListener('keydown', this.enterKeyHandler);\n      this.enterKeyHandler = null;\n    }\n  }\n\n  /**\n   * Setup global Enter key listener for form progression\n   * Allows users to press Enter to advance through the form\n   */\n  private setupEnterKeyListener(): void {\n    this.enterKeyHandler = (event: KeyboardEvent) => {\n      // Only respond to Enter without shift key\n      if (event.key !== 'Enter' || event.shiftKey) return;\n      this.form.logDebug('Enter key pressed', { event });\n\n      // Check if focus is within this form\n      const formElement = this.form.getRootElement()!;\n      const { activeElement } = document;\n      const isWithinForm = formElement.contains(activeElement);\n\n      if ((!isWithinForm && activeElement !== document.body) || activeElement?.tagName === 'BUTTON')\n        return;\n\n      // Prevent default form submission or other Enter key behaviors\n      event.preventDefault();\n\n      // determine whether to navigate or submit\n      const nextOrSubmit = this.form.buttonManager.determineNextOrSubmit();\n\n      if (nextOrSubmit === 'next') {\n        // Request navigation to next step\n        this.form.emit('form:navigation:request', { type: 'next' });\n      } else {\n        // Request form submission\n        this.form.emit('form:submit:requested', {});\n      }\n    };\n\n    document.addEventListener('keydown', this.enterKeyHandler);\n    this.form.logDebug('Global Enter key listener setup');\n  }\n\n  // ============================================\n  // Navigation requests\n  // ============================================\n\n  /**\n   * Handle move in a direction\n   */\n  public handleMove(direction: 'prev' | 'next' | 'submit'): void {\n    if (!this.navigationEnabled) return;\n\n    const canMove =\n      (direction === 'next' && this.validateCurrent()) ||\n      (direction === 'submit' && this.validateCurrent()) ||\n      direction === 'prev';\n    const behavior = this.form.getBehavior();\n    const destination = behavior.toLowerCase().replace('by', '');\n\n    if (canMove) {\n      this.logDebug(`Navigating to ${direction} ${destination}`);\n    } else {\n      this.logDebug(`Cannot navigate to ${direction} ${destination}`);\n      this.form.emit('form:navigation:denied', { reason: 'invalid' });\n      return;\n    }\n\n    if (direction === 'submit') {\n      this.byCard('next');\n      return;\n    }\n\n    switch (behavior) {\n      case 'byField':\n        this.byField(direction);\n        break;\n      case 'byGroup':\n        this.byGroup(direction);\n        break;\n      case 'bySet':\n        this.bySet(direction);\n        break;\n      case 'byCard':\n        this.byCard(direction);\n        break;\n      default:\n        throw this.form.createError('Invalid behavior', 'runtime', {\n          cause: { behavior },\n        });\n    }\n  }\n\n  private validateCurrent(): boolean {\n    const inputsToValidate = this.form.inputManager.getByFilter(\n      (input) => input.active && input.isIncluded\n    );\n\n    return inputsToValidate.every((input) => input.isValid);\n  }\n\n  /**\n   * Navigate to next field (byField behavior)\n   */\n  private byField(direction: 'prev' | 'next'): 'field' | 'group' | 'set' | 'card' | undefined {\n    const targetPosition =\n      direction === 'prev'\n        ? this.form.fieldManager.getPrevPosition()\n        : this.form.fieldManager.getNextPosition();\n\n    // At end of fields - check if we can advance to next group/set/card\n    if (targetPosition === undefined) {\n      return this.byGroup(direction);\n    }\n\n    const targetField = this.form.fieldManager.getByIndex(targetPosition);\n    if (!targetField) {\n      throw this.form.createError('Cannot handle navigation: target field is null', 'runtime', {\n        cause: { targetPosition, targetField, direction },\n      });\n    }\n\n    this.clearHierarchyData('field');\n    this.setChildrenActive(targetField);\n    this.updateHierarchyData(targetField);\n    this.batchStateUpdates();\n\n    return 'field';\n  }\n\n  /**\n   * Navigate to next group (byGroup behavior)\n   */\n  private byGroup(direction: 'prev' | 'next'): 'group' | 'set' | 'card' | undefined {\n    const targetPosition =\n      direction === 'prev'\n        ? this.form.groupManager.getPrevPosition()\n        : this.form.groupManager.getNextPosition();\n\n    // At end of groups - check if we can advance to next group/set/card\n    if (targetPosition === undefined) {\n      return this.bySet(direction);\n    }\n\n    const targetGroup = this.form.groupManager.getByIndex(targetPosition);\n    if (!targetGroup) {\n      throw this.form.createError('Cannot handle navigation: target group is null', 'runtime', {\n        cause: { targetPosition, targetGroup, direction },\n      });\n    }\n\n    // Clear active flags\n    this.clearHierarchyData('group');\n\n    // Set new group active and current\n    // this.form.groupManager.updateItemData(targetGroup.id, { active: true, current: true });\n    this.form.groupManager.setActive(targetGroup.id);\n    this.form.groupManager.setCurrent(targetGroup.id);\n    this.setChildrenActive(targetGroup);\n    this.updateHierarchyData(targetGroup);\n    this.batchStateUpdates();\n\n    return 'group';\n  }\n\n  /**\n   * Navigate to next group (byGroup behavior)\n   */\n  private bySet(direction: 'prev' | 'next'): 'set' | 'card' | undefined {\n    const targetPosition =\n      direction === 'prev'\n        ? this.form.setManager.getPrevPosition()\n        : this.form.setManager.getNextPosition();\n\n    // At end of sets - check if we can advance to next group/set/card\n    if (targetPosition === undefined) {\n      return this.byCard(direction);\n    }\n\n    const targetSet = this.form.setManager.getByIndex(targetPosition);\n    if (!targetSet) {\n      throw this.form.createError('Cannot handle navigation: target set is null', 'runtime', {\n        cause: { targetPosition, targetSet, direction },\n      });\n    }\n\n    // Clear active flags\n    this.clearHierarchyData('set');\n\n    // Set new group active and current\n    this.form.setManager.setActive(targetSet.id);\n    this.form.setManager.setCurrent(targetSet.id);\n    this.setChildrenActive(targetSet);\n    this.updateHierarchyData(targetSet);\n    this.batchStateUpdates();\n\n    return 'set';\n  }\n\n  /**\n   * Navigate to next group (byGroup behavior)\n   */\n  private byCard(direction: 'prev' | 'next'): 'card' | undefined {\n    const targetPosition =\n      direction === 'prev'\n        ? this.form.cardManager.getPrevPosition()\n        : this.form.cardManager.getNextPosition();\n\n    // At end of cards - check if we can advance to next group/set/card\n    if (targetPosition === undefined) {\n      // this.handleFormComplete();\n      return undefined;\n    }\n\n    const targetCard = this.form.cardManager.getByIndex(targetPosition);\n    if (!targetCard) {\n      throw this.form.createError('Cannot handle navigation: target card is null', 'runtime', {\n        cause: { targetPosition, targetCard, direction },\n      });\n    }\n\n    // Clear active flags\n    this.clearHierarchyData('card');\n\n    // Set new group active and current\n    this.form.cardManager.setActive(targetCard.id);\n    this.form.cardManager.setCurrent(targetCard.id);\n    this.setChildrenActive(targetCard);\n    this.batchStateUpdates();\n\n    return 'card';\n  }\n\n  /**\n   * Clear child metadata for any element\n   * Cascades down the hierarchy: card \u2192 set \u2192 group \u2192 field\n   * Clears all levels below and including the given element type\n   *\n   * @param elementType - The element type to start clearing from\n   */\n  private clearHierarchyData(elementType: 'card' | 'set' | 'group' | 'field'): void {\n    // Clear card and below\n    if (elementType === 'card') {\n      this.form.cardManager.clearActiveAndCurrent();\n    }\n\n    // Clear set and below\n    if (elementType === 'card' || elementType === 'set') {\n      this.form.setManager.clearActiveAndCurrent();\n    }\n\n    // Clear group and below\n    if (elementType === 'card' || elementType === 'set' || elementType === 'group') {\n      this.form.groupManager.clearActiveAndCurrent();\n    }\n\n    // Clear field (always cleared for all element types)\n    this.form.fieldManager.clearActiveAndCurrent();\n  }\n\n  /**\n   * Set children active (first is current)\n   */\n  private setChildrenActive(element: CardItem | SetItem | GroupItem | FieldItem): void {\n    if (element.type === 'card') {\n      this.form.setManager.setActiveByParent(element.id, element.type, { firstIsCurrent: true });\n    }\n\n    if (element.type === 'card' || element.type === 'set') {\n      this.form.groupManager.setActiveByParent(element.id, element.type, { firstIsCurrent: true });\n    }\n\n    if (element.type === 'card' || element.type === 'set' || element.type === 'group') {\n      this.form.fieldManager.setActiveByParent(element.id, element.type, { firstIsCurrent: true });\n    }\n\n    this.form.inputManager.clearActiveAndCurrent();\n    const activeFields = this.form.fieldManager.getActive();\n    activeFields.forEach((field, index) => {\n      this.form.inputManager.setActiveByParent(field.id, 'field', {\n        firstIsCurrent: index === 0,\n      });\n    });\n  }\n\n  /**\n   * Update parent metadata for any element\n   * Cascades up the hierarchy: field \uFFFD group \uFFFD set \uFFFD card\n   * Only updates parents that exist in the element's hierarchy\n   *\n   * @param element - Any form element (field, group, set, card)\n   */\n  private updateHierarchyData(element: SetItem | GroupItem | FieldItem): void {\n    // Update group (only if element is a field)\n    if (element.type === 'field') {\n      const { groupIndex } = element.parentHierarchy;\n      if (groupIndex !== null && groupIndex >= 0) {\n        this.form.groupManager.clearActiveAndCurrent();\n        this.form.groupManager.setActive(groupIndex);\n        this.form.groupManager.setCurrent(groupIndex);\n      }\n    }\n\n    // Update set (if element is field or group)\n    if (element.type === 'field' || element.type === 'group') {\n      const { setIndex } = element.parentHierarchy;\n      if (setIndex !== null && setIndex >= 0) {\n        this.form.setManager.clearActiveAndCurrent();\n        this.form.setManager.setActive(setIndex);\n        this.form.setManager.setCurrent(setIndex);\n      }\n    }\n\n    // Update card (always, since all elements have a parent card)\n    const { cardIndex } = element.parentHierarchy;\n    if (cardIndex !== null && cardIndex >= 0) {\n      this.form.cardManager.clearActiveAndCurrent();\n      this.form.cardManager.setActive(cardIndex);\n      this.form.cardManager.setCurrent(cardIndex);\n    }\n  }\n\n  /**\n   * Batch all manager state calculations into one setStates() call\n   * Prevents multiple state:changed events and DisplayManager flicker\n   */\n  private batchStateUpdates(): void {\n    this.form.inputManager.rebuildAll();\n    this.form.fieldManager.rebuildAll();\n    this.form.groupManager.rebuildAll();\n    this.form.setManager.rebuildAll();\n    this.form.cardManager.rebuildAll();\n\n    // Collect state from all managers (doesn't write to state yet)\n    const allStates = {\n      ...this.form.inputManager.calculateStates(),\n      ...this.form.fieldManager.calculateStates(),\n      ...this.form.groupManager.calculateStates(),\n      ...this.form.setManager.calculateStates(),\n      ...this.form.cardManager.calculateStates(),\n    };\n\n    // Batch update all states\n    this.form.setStates(allStates);\n  }\n}\n", "import { ATTR } from '../constants';\nimport type { FormBehavior } from '../types';\nimport type {\n  ProgressItem,\n  ProgressParentElement,\n  ProgressParentHierarchy,\n} from '../types/items/progress-item';\nimport { parseElementAttribute } from '../utils';\nimport { HierarchyBuilder } from '../utils/managers/hierarchy-builder';\nimport { ItemStore } from '../utils/managers/item-store';\nimport { BaseManager } from './base-manager';\n\nexport class ProgressManager extends BaseManager {\n  private store = new ItemStore<ProgressItem>();\n\n  public init(): void {\n    this.groupStart(`Initializing Progress`);\n    this.discoverItems();\n    this.setupEventListeners();\n\n    this.logDebug('Initialized');\n    this.groupEnd();\n  }\n\n  public destroy(): void {\n    this.store.clear();\n    this.logDebug('ProgressManager destroyed');\n  }\n\n  private discoverItems(): void {\n    const rootElement = this.form.getRootElement();\n    if (!rootElement) {\n      throw this.form.createError('Cannot discover progress items: root element is null', 'init', {\n        cause: rootElement,\n      });\n    }\n\n    // Query all buttons\n    const items = this.form.queryAll<HTMLElement>(`[${ATTR}-element=\"progress-line\"]`);\n\n    this.store.clear();\n\n    items.forEach((item, index) => {\n      const itemData = this.createItemData(item, index);\n      if (!itemData) return;\n\n      this.store.add(itemData);\n    });\n\n    this.logDebug(`Discovered ${this.store.length} progress lines`, {\n      items: this.store.getAll(),\n    });\n  }\n\n  private createItemData(element: HTMLElement, index: number): ProgressItem | undefined {\n    if (!(element instanceof HTMLElement)) return;\n\n    const attrValue = element.getAttribute(`${ATTR}-element`);\n    if (!attrValue) return;\n\n    const parsed = parseElementAttribute(attrValue);\n    if (!parsed) return;\n\n    // Skip if not a progress line\n    if (parsed.type !== 'progress-line') return;\n\n    return this.buildItemData({\n      element,\n      index,\n      id: parsed.id ?? `progress-line-${index}`,\n      visible: true,\n      active: false, // Calculated\n      type: parsed.type,\n      parentHierarchy: this.findParentHierarchy(element),\n    });\n  }\n\n  private buildItemData(item: ProgressItem): ProgressItem {\n    return {\n      ...item,\n      active: true,\n    };\n  }\n\n  private findParentHierarchy(child: HTMLElement): ProgressParentHierarchy {\n    return HierarchyBuilder.findParentHierarchy<ProgressParentHierarchy>(\n      child,\n      this.form,\n      (element) => this.findParentItem(element)\n    );\n  }\n\n  /**\n   * Find the parent item for a progress line\n   *\n   * @param element - The progress line element\n   * @returns Parent data or undefined\n   */\n  protected findParentItem(element: HTMLElement): ProgressParentElement | undefined {\n    const parentGroup = HierarchyBuilder.findParentByElement(element, 'group', () =>\n      this.form.groupManager.getAll()\n    );\n\n    const parentSet = HierarchyBuilder.findParentByElement(element, 'set', () =>\n      this.form.setManager.getAll()\n    );\n\n    const parentCard = HierarchyBuilder.findParentByElement(element, 'card', () =>\n      this.form.cardManager.getAll()\n    );\n\n    return parentGroup ?? parentSet ?? parentCard;\n  }\n\n  private setupEventListeners(): void {\n    this.form.subscribe('form:navigation:changed', () => {\n      this.updateProgress();\n    });\n  }\n\n  private updateProgress(): void {\n    this.store.getAll().forEach((item) => {\n      const progress = this.getProgressForBehavior(item);\n      if (progress === undefined) return;\n      item.element.style.setProperty('--progress', progress.toString());\n    });\n  }\n\n  /**\n   * Progress calculation config\n   * First key: Where progress bar is placed (parent context)\n   * Second key: What we're tracking (behavior)\n   */\n  private static readonly PROGRESS_CONFIG: Record<\n    'form' | 'card' | 'set',\n    Partial<\n      Record<\n        FormBehavior,\n        {\n          manager: 'cardManager' | 'setManager' | 'groupManager' | 'fieldManager';\n          parentType: 'form' | 'card' | 'set';\n          stateKey:\n            | 'currentCardIndex'\n            | 'currentSetIndex'\n            | 'currentGroupIndex'\n            | 'currentFieldIndex';\n        }\n      >\n    >\n  > = {\n    form: {\n      byCard: {\n        manager: 'cardManager',\n        parentType: 'form',\n        stateKey: 'currentCardIndex',\n      },\n      bySet: {\n        manager: 'setManager',\n        parentType: 'form',\n        stateKey: 'currentSetIndex',\n      },\n      byGroup: {\n        manager: 'groupManager',\n        parentType: 'form',\n        stateKey: 'currentGroupIndex',\n      },\n      byField: {\n        manager: 'fieldManager',\n        parentType: 'form',\n        stateKey: 'currentFieldIndex',\n      },\n    },\n    card: {\n      bySet: {\n        manager: 'setManager',\n        parentType: 'card',\n        stateKey: 'currentSetIndex',\n      },\n      byGroup: {\n        manager: 'groupManager',\n        parentType: 'card',\n        stateKey: 'currentGroupIndex',\n      },\n      byField: {\n        manager: 'fieldManager',\n        parentType: 'card',\n        stateKey: 'currentFieldIndex',\n      },\n    },\n    set: {\n      byGroup: {\n        manager: 'groupManager',\n        parentType: 'set',\n        stateKey: 'currentGroupIndex',\n      },\n      byField: {\n        manager: 'fieldManager',\n        parentType: 'set',\n        stateKey: 'currentFieldIndex',\n      },\n    },\n  };\n\n  /**\n   * Get progress for item based on its parent context and current behavior\n   */\n  private getProgressForBehavior(item: ProgressItem): number | undefined {\n    const behavior = this.form.getBehavior();\n    const { parentHierarchy } = item;\n\n    // Determine progress bar's parent context (most specific first)\n    const parentContext = this.getParentContext(parentHierarchy);\n    if (!parentContext) return undefined;\n\n    const [contextLevel, parentId] = parentContext;\n\n    // Get config for this parent context + behavior combination\n    const config = ProgressManager.PROGRESS_CONFIG[contextLevel]?.[behavior];\n    if (!config) return undefined; // No valid combination\n\n    const { manager, parentType, stateKey } = config;\n\n    // Get siblings within the parent\n    const managerInstance = this.form[manager];\n    const siblings =\n      parentType === 'form'\n        ? managerInstance.getAll()\n        : managerInstance.getAllByParentId(parentId, parentType);\n    if (siblings.length === 0) return undefined;\n\n    // Get current index\n    const state = this.form.getAllState();\n    const currentIndex = state[stateKey];\n\n    // Find position\n    const currentPosition = siblings.findIndex((s) => s.index === currentIndex);\n    if (currentPosition === -1) return undefined;\n\n    return ((currentPosition + 1) / siblings.length) * 100;\n  }\n\n  /**\n   * Determine the parent context level for a progress item\n   * Returns [contextLevel, parentId] or undefined\n   * Checks from most specific (group) to least specific (form)\n   */\n  private getParentContext(\n    hierarchy: ProgressParentHierarchy\n  ): ['set' | 'card' | 'form', string] | undefined {\n    // Check set (most specific)\n    if ('setId' in hierarchy && hierarchy.setId) {\n      return ['set', hierarchy.setId];\n    }\n\n    // Check card\n    if ('cardId' in hierarchy && hierarchy.cardId) {\n      return ['card', hierarchy.cardId];\n    }\n\n    // Check form (least specific)\n    if (hierarchy.formId) {\n      return ['form', hierarchy.formId];\n    }\n\n    return undefined;\n  }\n}\n", "/**\n * Set Manager\n *\n * Handles set discovery and access throughout the form lifecycle.\n * Sets are semantic groupings of related fields (typically using <fieldset>).\n */\n\nimport { ATTR } from '../constants/attr';\nimport type { CardItem, FormSetState, SetItem, SetParentHierarchy } from '../types';\nimport { extractTitle, parseElementAttribute } from '../utils';\nimport { HierarchyBuilder } from '../utils/managers/hierarchy-builder';\nimport { ItemManager } from './item-manager';\n\n/**\n * SetManager Implementation\n *\n * Discovers and manages set elements in the form hierarchy.\n * Provides access to sets by index or ID.\n * Associates sets with their parent cards.\n */\nexport class SetManager extends ItemManager<SetItem> {\n  protected readonly itemType = 'set';\n\n  /**\n   * Create data object\n   * Parses the element attribute and creates a SetItem object\n   *\n   * @param element - HTMLElement\n   * @param index - Index of the element within the list of sets\n   * @returns SetItem | undefined\n   */\n  protected createItemData(element: HTMLElement, index: number): SetItem | undefined {\n    if (!(element instanceof HTMLElement)) return;\n\n    const attrValue = element.getAttribute(`${ATTR}-element`);\n    if (!attrValue) return;\n\n    const parsed = parseElementAttribute(attrValue);\n\n    // Skip if not a set\n    if (parsed.type !== this.itemType) return;\n\n    // Extract title with priority resolution\n    const titleData = extractTitle(element, this.itemType, parsed.id, index);\n\n    // Find parent card (if cards exist)\n    const parentHierarchy = this.findParentHierarchy<SetParentHierarchy>(element);\n    const active = this.determineActive(element, index);\n\n    // Create set item object\n    return {\n      element,\n      index,\n      id: titleData.id,\n      visible: true,\n      active,\n      parentHierarchy,\n      current: active && index === 0,\n      visited: active,\n      completed: false,\n      type: this.itemType,\n      title: titleData.title,\n      progress: 0,\n      isIncluded: true,\n      isValid: false,\n    };\n  }\n\n  /**\n   * Calculate set-specific states\n   * Aggregates data from all sets and their child groups and fields\n   *\n   * @returns FormSetState - Complete set state object\n   */\n  public calculateStates(): FormSetState {\n    const currentSet = this.getCurrent();\n    const currentSetIndex = currentSet ? currentSet.index : -1;\n    const currentSetId = currentSet ? currentSet.id : null;\n    const currentSetTitle = currentSet ? currentSet.title : null;\n    const previousSetIndex = currentSetIndex > 0 ? currentSetIndex - 1 : null;\n    const nextSetIndex = currentSetIndex < this.length - 1 ? currentSetIndex + 1 : null;\n    const completedSets = new Set(\n      this.getByFilter((item) => item.completed).map((item) => item.id)\n    );\n    const visitedSets = new Set(this.getByFilter((item) => item.visited).map((item) => item.id));\n    const totalSets = this.length;\n    const setsComplete = completedSets.size;\n    const setValidity = this.getAll().reduce(\n      (acc, item) => {\n        acc[item.id] = item.isValid;\n        return acc;\n      },\n      {} as Record<string, boolean>\n    );\n\n    return {\n      currentSetIndex,\n      currentSetId,\n      currentSetTitle,\n      activeSetIndices: this.getActiveIndices(),\n      previousSetIndex,\n      nextSetIndex,\n      completedSets,\n      visitedSets,\n      totalSets,\n      setsComplete,\n      setValidity,\n    };\n  }\n\n  protected buildItemData(item: SetItem): SetItem {\n    const groups = this.form.groupManager.getAllByParentId(item.id, 'set');\n    const fields = this.form.fieldManager\n      .getAllByParentId(item.id, 'set')\n      .filter((field) => field.isIncluded);\n\n    const use = groups.length > 0 ? groups : fields;\n\n    const completed = use.every((item) => item.completed);\n    const isValid = use.every((item) => item.isValid);\n    const progress = (use.filter((item) => item.completed).length / use.length) * 100;\n\n    // Evaluate conditional visibility\n    const isIncluded = this.form.conditionManager.evaluateElementCondition(item.element);\n\n    return {\n      ...item,\n      completed,\n      isValid,\n      progress,\n      isIncluded,\n    };\n  }\n\n  /**\n   * Find the parent item for a set\n   *\n   * @param element - The set element\n   * @returns Parent data or null\n   */\n  protected findParentItem(element: HTMLElement): CardItem | undefined {\n    return HierarchyBuilder.findParentByElement(element, 'card', () =>\n      this.form.cardManager.getAll()\n    );\n  }\n}\n", "import type { FlowupsForm } from '..';\nimport { BaseManager } from './base-manager';\n\nexport class SubmitManager extends BaseManager {\n  private formElement: HTMLFormElement;\n\n  constructor(form: FlowupsForm) {\n    super(form);\n    this.formElement = this.discoverForm();\n  }\n\n  public init(): void {\n    this.groupStart(`Initializing Submit`);\n    this.discoverForm();\n    this.setupEventListeners();\n\n    this.logDebug('Initialized', {\n      formElement: this.formElement,\n    });\n    this.groupEnd();\n  }\n\n  public destroy(): void {\n    this.logDebug('SubmitManager destroyed');\n  }\n\n  private setupEventListeners(): void {\n    this.form.subscribe('form:submit:requested', () => {\n      this.handleSubmit();\n    });\n\n    this.formElement.addEventListener('submit', (event) => {\n      event.preventDefault();\n      this.handleSubmit();\n    });\n\n    this.form.subscribe('form:submit:error', (payload) => {\n      this.logDebug('Form submit error', { error: payload.error });\n      this.showError(payload.error.message);\n    });\n  }\n\n  private discoverForm(): HTMLFormElement {\n    const rootElement = this.form.getRootElement();\n    if (!rootElement) {\n      throw this.form.createError('Cannot discover form: root element is null', 'init', {\n        cause: rootElement,\n      });\n    }\n\n    let formElement: HTMLFormElement;\n\n    if (!(rootElement instanceof HTMLFormElement)) {\n      const childForm = rootElement.querySelector('form');\n      if (!childForm) {\n        throw this.form.createError('Cannot discover form: child form is null', 'init', {\n          cause: rootElement,\n        });\n      }\n\n      formElement = childForm;\n    } else {\n      formElement = rootElement;\n    }\n\n    return formElement;\n  }\n\n  public handleSubmit(): void {\n    this.logDebug('Form submit requested', {\n      data: this.form.getState('formData'),\n    });\n\n    this.form.emit('form:submit:started', {});\n  }\n\n  public setLoading(isLoading: boolean): void {\n    const submit = this.form.buttonManager.getSubmit();\n    if (!submit) return;\n\n    submit.button.disabled = isLoading;\n    this.form.buttonManager.setText(submit.button, isLoading ? 'Submitting...' : undefined);\n  }\n\n  public showSuccess(): void {\n    this.form.emit('form:navigation:request', { type: 'submit' });\n  }\n\n  public showError(message: string, timeout?: number): void {\n    this.form.emit('form:error:triggered', { message, timeout });\n  }\n}\n", "/**\n * Multi-Step Form Component\n *\n * Main component that orchestrates the multi-step form system.\n * Extends StatefulComponent for state management, event handling, and lifecycle.\n */\n\nimport { StatefulComponent } from '$lib/core/components/stateful-component';\n\nimport {\n  ButtonManager,\n  CardManager,\n  ConditionManager,\n  DisplayManager,\n  ErrorManager,\n  FieldManager,\n  FocusManager,\n  GroupManager,\n  InputManager,\n  NavigationManager,\n  ProgressManager,\n  SetManager,\n  SubmitManager,\n} from './managers';\nimport type {\n  FlowupsFormConfig,\n  FlowupsFormProps,\n  FormAttributeConfig,\n  FormBehavior,\n  FormEventMap,\n  FormState,\n  StorageType,\n} from './types';\nimport {\n  getConfigAttributes,\n  isValidBehaviorType,\n  isValidErrorModeType,\n  isValidStorageType,\n  isValidTransitionType,\n  parseBooleanAttribute,\n  parseNumberAttribute,\n} from './utils';\n\n/**\n * Flowups Form Component\n *\n * Manages the complete lifecycle of a multi-step form including:\n * - Element hierarchy discovery (cards, sets, groups, fields)\n * - Navigation and progression\n * - Validation and error handling\n * - Conditional visibility\n * - Progress tracking\n * - Animations and transitions\n * - Accessibility\n */\nexport class FlowupsForm extends StatefulComponent<FormState, FormEventMap> {\n  protected readonly config: FlowupsFormConfig;\n  public submitManager: SubmitManager;\n  public errorManager: ErrorManager;\n  public cardManager: CardManager;\n  public setManager: SetManager;\n  public groupManager: GroupManager;\n  public fieldManager: FieldManager;\n  public inputManager: InputManager;\n  public buttonManager: ButtonManager;\n  public navigationManager: NavigationManager;\n  public displayManager: DisplayManager;\n  public progressManager: ProgressManager;\n  public focusManager: FocusManager;\n  public conditionManager: ConditionManager;\n  // private accessibilityManager: AccessibilityManager;\n  // private animationManager: AnimationManager;\n  // private renderManager: RenderManager;\n  // private validationManager: ValidationManager;\n\n  /**\n   * Create a new MultiStepForm instance\n   * @param props - Props for the MultiStepForm component\n   */\n  constructor(props: FlowupsFormProps) {\n    // Initialize StatefulComponent\n    super(props);\n\n    // Set the form element as the root element and parse configuration\n    this.setRootElement(props.selector);\n    this.config = this.parseConfiguration();\n\n    // Initialize managers\n    this.submitManager = new SubmitManager(this);\n    this.errorManager = new ErrorManager(this);\n    this.cardManager = new CardManager(this);\n    this.setManager = new SetManager(this);\n    this.groupManager = new GroupManager(this);\n    this.fieldManager = new FieldManager(this);\n    this.inputManager = new InputManager(this);\n    this.buttonManager = new ButtonManager(this);\n    this.navigationManager = new NavigationManager(this);\n    this.displayManager = new DisplayManager(this);\n    this.progressManager = new ProgressManager(this);\n    this.focusManager = new FocusManager(this);\n    this.conditionManager = new ConditionManager(this);\n\n    if (this.config.autoInit && !this.isInitialized()) this.init();\n  }\n\n  /**\n   * Parse configuration from ${ATTR}* attributes\n   * Attributes override config object\n   */\n  private parseConfiguration(): FlowupsFormConfig {\n    // Get all ${ATTR}* attributes (type-safe with FormAttributeConfig)\n    const attrs = getConfigAttributes<FormAttributeConfig>(this.rootElement as HTMLElement);\n\n    // Parse name\n    if (!attrs.name) {\n      throw this.createError(`Invalid configuration: No name is provided for form`, 'init', {\n        cause: {\n          element: this.rootElement as HTMLElement,\n          name: attrs.name,\n        },\n      });\n    }\n\n    // Parse behavior\n    if (attrs.behavior && !isValidBehaviorType(attrs.behavior)) {\n      throw this.createError(\n        `Invalid configuration: Behavior must be 'byField', 'bySet', 'byGroup', or 'byCard'`,\n        'init',\n        {\n          cause: {\n            behavior: attrs.behavior,\n          },\n        }\n      );\n    }\n\n    // Parse transition type\n    if (attrs.transition && !isValidTransitionType(attrs.transition)) {\n      throw this.createError(\n        `Invalid configuration: Transition must be \"fade\", \"slide\", or \"none\"`,\n        'init',\n        {\n          cause: {\n            transition: attrs.transition,\n          },\n        }\n      );\n    }\n\n    // Parse transition duration\n    if (attrs.transitionduration && isNaN(parseFloat(attrs.transitionduration))) {\n      throw this.createError(\n        `Invalid configuration: Transition duration must be a number`,\n        'init',\n        {\n          cause: {\n            transitionDuration: attrs.transitionduration,\n          },\n        }\n      );\n    }\n\n    // Parse allow invalid\n    if (attrs.allowinvalid && !['true', 'false', ''].includes(attrs.allowinvalid)) {\n      throw this.createError(\n        `Invalid configuration: Allow invalid must be 'true' or 'false'`,\n        'init',\n        {\n          cause: {\n            allowInvalid: attrs.allowinvalid,\n          },\n        }\n      );\n    }\n\n    // Parse error display mode\n    if (attrs.errordisplay && !isValidErrorModeType(attrs.errordisplay)) {\n      throw this.createError(`Invalid configuration: Error display mode must be 'native'`, 'init', {\n        cause: { errordisplay: attrs.errordisplay },\n      });\n    }\n\n    // Parse aria announce\n    if (attrs.ariaannounce && !['true', 'false', ''].includes(attrs.ariaannounce)) {\n      throw this.createError(\n        `Invalid configuration: Aria announce must be 'true' or 'false'`,\n        'init',\n        {\n          cause: {\n            ariaAnnounce: attrs.ariaannounce,\n          },\n        }\n      );\n    }\n\n    // Parse focus on change\n    if (attrs.focusonchange && !['true', 'false', ''].includes(attrs.focusonchange)) {\n      throw this.createError(\n        `Invalid configuration: Focus on change must be 'true' or 'false'`,\n        'init',\n        {\n          cause: {\n            focusOnChange: attrs.focusonchange,\n          },\n        }\n      );\n    }\n\n    // Parse auto init\n    if (attrs.autoinit && !['true', 'false', ''].includes(attrs.autoinit)) {\n      throw this.createError(`Invalid configuration: Auto init must be 'true' or 'false'`, 'init', {\n        cause: { autoInit: attrs.autoinit },\n      });\n    }\n\n    // Parse storage type\n    if (attrs.persist && !isValidStorageType(attrs.persist)) {\n      throw this.createError(`Invalid configuration: Persist must be 'memory'`, 'init', {\n        cause: { persist: attrs.persist },\n      });\n    }\n\n    // Parse debug\n    let debug: boolean = false;\n    if (attrs.debug === 'staging') debug = window.location.hostname.includes('webflow.io');\n    else if (attrs.debug && ['true', 'false', ''].includes(attrs.debug)) {\n      debug = parseBooleanAttribute(attrs.debug, false);\n    }\n\n    this.props.debug = debug;\n\n    // Set defaults if not provided\n    return {\n      name: attrs.name || 'untitled-form',\n      behavior: attrs.behavior || 'byField',\n      transition: attrs.transition || 'none',\n      transitionDuration: parseNumberAttribute(attrs.transitionduration, 300),\n      validateOn: attrs.validateon || 'blur',\n      allowInvalid: parseBooleanAttribute(attrs.allowinvalid, false),\n      errorDisplay: attrs.errordisplay || 'native',\n      ariaAnnounce: parseBooleanAttribute(attrs.ariaannounce, true),\n      focusOnChange: parseBooleanAttribute(attrs.focusonchange, true),\n      autoInit: parseBooleanAttribute(attrs.autoinit, false),\n      persist: (attrs.persist as StorageType) || 'memory',\n      debug,\n    };\n  }\n\n  // ============================================\n  // Event Listeners\n  // ============================================\n\n  /**\n   * Set up event listeners\n   * Required by InteractiveComponent\n   */\n  protected async setupEventListeners(): Promise<void> {}\n\n  /**\n   * Initialize the form\n   * Called by StatefulComponent lifecycle\n   */\n  protected async onInit(): Promise<void> {\n    await super.onInit();\n\n    this.groupStart(`[FLOWUPS-DEBUG] Form: Initializing \"${this.getId()}\"`, false);\n    this.logDebug(`Started at ${new Date().toISOString()}`);\n    this.timeDebug('form:init');\n\n    this.submitManager.init();\n    this.errorManager.init();\n    this.conditionManager.init();\n    this.cardManager.init();\n    this.setManager.init();\n    this.groupManager.init();\n    this.fieldManager.init();\n    this.inputManager.init();\n    this.buttonManager.init();\n    this.displayManager.init();\n    this.navigationManager.init();\n    this.progressManager.init();\n    this.focusManager.init();\n\n    this.logDebug(`Form initialized`, {\n      state: this.getAllState(),\n      timestamp: new Date().toISOString(),\n    });\n\n    this.emit('form:initialized', { formId: this.getId() });\n\n    this.timeDebug('form:init', true);\n\n    this.groupEnd();\n  }\n\n  /**\n   * Cleanup on destroy\n   * Called by StatefulComponent lifecycle\n   */\n  protected async onDestroy(): Promise<void> {\n    this.logDebug(`Destroying form`);\n\n    // TODO Phase 1 Step 3:\n    // - Destroy all managers\n    // - Emit form:destroyed event\n\n    this.submitManager.destroy();\n    this.errorManager.destroy();\n    this.cardManager.destroy();\n    this.setManager.destroy();\n    this.groupManager.destroy();\n    this.fieldManager.destroy();\n    this.inputManager.destroy();\n    this.navigationManager.destroy();\n    this.displayManager.destroy();\n    this.buttonManager.destroy();\n    this.progressManager.destroy();\n    this.focusManager.destroy();\n    this.conditionManager.destroy();\n\n    await super.onDestroy();\n\n    this.emit('form:destroyed', { formId: this.getId() });\n  }\n\n  /**\n   * Handle state changes\n   * Called by StatefulComponent when state changes\n   */\n  protected handleStateChange<K extends keyof FormState>(\n    key: K,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    from: FormState[K],\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    to: FormState[K]\n  ): void {\n    switch (key) {\n      case 'currentCardIndex':\n        return this.emit('form:navigation:changed', { target: 'card' });\n      case 'currentSetIndex':\n        return this.emit('form:navigation:changed', { target: 'set' });\n      case 'currentGroupIndex':\n        return this.emit('form:navigation:changed', { target: 'group' });\n      case 'currentFieldIndex':\n        return this.emit('form:navigation:changed', { target: 'field' });\n      case 'activeFieldIndices':\n        return this.emit('form:navigation:changed', { target: 'field' });\n      default:\n        return;\n    }\n  }\n\n  /**\n   * Get form name\n   */\n  public getFormName(): string {\n    return this.config.name;\n  }\n\n  /**\n   * Get current behavior\n   */\n  public getBehavior(): FormBehavior {\n    return this.config.behavior;\n  }\n\n  /**\n   * Get configuration\n   */\n  public getFormConfig(): Readonly<FlowupsFormConfig> {\n    return Object.freeze({ ...this.config });\n  }\n\n  /**\n   * Get state value\n   */\n  public getState<K extends keyof FormState>(key: K): FormState[K] {\n    return super.getState(key);\n  }\n}\n", "import { FlowupsForm } from './form';\nimport { ATTR } from './form/constants';\n\ninterface MotifFormAPI {\n  id: string;\n  getAllState: () => Record<string, unknown>;\n  getBehavior: () => ReturnType<FlowupsForm['getBehavior']>;\n  getFormConfig: () => ReturnType<FlowupsForm['getFormConfig']>;\n  getFormData: () => Record<string, unknown>;\n  setLoading: (isLoading: boolean) => void;\n  showSuccess: () => void;\n  showError: (message: string, timeout?: number) => void;\n  onSubmit: (callback: (formData: Record<string, unknown>) => void) => void;\n  onMount: (callback: () => void) => void;\n  onUnmount: (callback: () => void) => void;\n  push: (callback: () => void) => void;\n}\n\ndeclare global {\n  interface Window {\n    MotifForm: MotifFormAPI | Array<() => void>;\n  }\n}\n\n// Preserve any queued callbacks from early initialization\nconst initQueue = (window.MotifForm as Array<() => void>) || [];\n\nwindow.Webflow ||= [];\nwindow.Webflow.push(() => {\n  const form = document.querySelector(`form[${ATTR}-element=\"form\"]`);\n  if (!form || !(form instanceof HTMLFormElement)) return;\n\n  const name = form.getAttribute('name') ?? 'untitled-form';\n\n  const flowupsForm = new FlowupsForm({ selector: form });\n\n  // Helper to process queued callbacks once API is ready\n  const processQueue = () => {\n    initQueue.forEach((cb) => cb());\n  };\n\n  // Replace with actual implementation\n  window.MotifForm = {\n    id: flowupsForm.getFormName(),\n    getAllState: () => {\n      return flowupsForm.getAllState();\n    },\n    getBehavior: () => {\n      return flowupsForm.getBehavior();\n    },\n    getFormConfig: () => {\n      return flowupsForm.getFormConfig();\n    },\n    getFormData: () => {\n      return flowupsForm.getState('formData');\n    },\n    setLoading: (isLoading: boolean) => {\n      flowupsForm.submitManager.setLoading(isLoading);\n    },\n    showSuccess: () => {\n      flowupsForm.submitManager.showSuccess();\n    },\n    showError: (message: string, timeout?: number) => {\n      flowupsForm.submitManager.showError(message, timeout);\n    },\n    onSubmit: (callback: (formData: Record<string, unknown>) => void) => {\n      flowupsForm.subscribe('form:submit:started', () => {\n        const formData = flowupsForm.getState('formData');\n        callback(formData);\n      });\n    },\n    onMount: (callback: () => void) => {\n      if (flowupsForm.isInitialized()) {\n        callback();\n      } else {\n        flowupsForm.subscribe('form:initialized', ({ formId }) => {\n          if (formId !== name) return;\n          callback();\n        });\n      }\n    },\n    onUnmount: (callback: () => void) => {\n      flowupsForm.subscribe('form:destroyed', ({ formId }) => {\n        if (formId !== name) return;\n        callback();\n      });\n    },\n\n    // Support late initialization - execute callbacks immediately since API is ready\n    push: (callback: () => void) => {\n      callback();\n    },\n  };\n\n  // Process queued callbacks after form is fully initialized\n  if (flowupsForm.isInitialized()) {\n    processQueue();\n  } else {\n    flowupsForm.subscribe('form:initialized', () => {\n      processQueue();\n    });\n  }\n});\n"],
  "mappings": "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",
  "names": ["element", "parent", "parent", "child", "input", "item"]
}
